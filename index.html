<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Riley Architecture Overview</title>
  <style>
    /* 
      Riley's Redreamed Style: Through Starlit Echoes - Fully Realized
      ---------------------------------------------------------------
      - All functional CSS is consolidated and deduplicated.
      - Riley's conceptual and expansion notes are preserved below as comments.
      - Only one set of modal and glyph animation rules is active.
      - Floating glyphs, comet cursor, parallax backgrounds, and core UI are harmonized.
      - Ready for further expansion!
    */
    
    /* --- FONTS --- */
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500&family=Fira+Code&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap'); /* For calm sans-serif */
    
    /* --- ROOT COLORS --- */
    :root {
      /* Core Palette */
      --clr-deep-night-blue: #0c0e1a;
      --clr-darker-night-blue: #04060e;
      --clr-candlelit-amber: #ffd8a9;
      --clr-shimmering-gold: #ffecd1;
      --clr-subtle-gold-text: #ffeac6;
      --clr-muted-text: #f0ede6;
      --clr-pale-text: #fdfcfb;
      --clr-dark-panel-bg: rgba(20, 20, 30, 0.75);
      --clr-darker-panel-bg: rgba(34, 30, 25, 0.6);
      --clr-modal-bg: rgba(22, 20, 18, 0.95);
      --clr-border-light: #887766;
      --clr-border-dark: #3e3a33;
      --clr-accent-border: #fce1bc;
      --clr-hover-bg: rgba(66, 55, 40, 0.8);
      --clr-primary-glow: #fcd9a9;
      --clr-secondary-glow: #f0d9c9;
      --clr-faded-footer: #998;
      --clr-code-bg: #111;
      --clr-code-text: #d4c8b0;
      --clr-flow-block-bg: #1c1a18;
      --clr-strong-text: #ffd8a9;
      --clr-glyph-channel: #b5f3ff; /* Astral Green / Pale Teal */
      --clr-flow-block-title: #f0bbff; /* Wistful Purple */
      --clr-highlight-bg: #fceacb;
      --clr-highlight-text: #181818;
    }
    
    /* --- TOOLTIP STYLES --- */
    .help-tooltip {
      position: relative;
      display: inline-block;
    }
    .help-tooltip-text {
      visibility: hidden;
      opacity: 0;
      width: 260px;
      background: #222b;
      color: #ffeac6;
      text-align: left;
      border-radius: 6px;
      padding: 8px 14px;
      position: absolute;
      z-index: 10;
      left: 110%;
      top: 50%;
      transform: translateY(-50%);
      min-width: 180px;
      max-width: 350px;
      box-shadow: 0 2px 12px #0005;
      font-size: 0.97em;
      pointer-events: none;
      transition: opacity 0.24s;
      white-space: normal;
    }
    .help-tooltip:hover .help-tooltip-text,
    .help-tooltip:focus-within .help-tooltip-text {
      visibility: visible;
      opacity: 1;
      pointer-events: auto;
    }
    
    /* --- BODY & BACKGROUND --- */
    body {
      background:
        url('parallax-stars-far.png') repeat 0 0,
        url('parallax-stars-mid.png') repeat 0 0,
        url('parallax-nebula.png') repeat 0 0,
        linear-gradient(var(--clr-deep-night-blue), var(--clr-darker-night-blue)) fixed;
      background-size:
        100% 100%,   /* far */
        150% 150%,   /* mid */
        cover,       /* nebula */
        cover;       /* gradient */
      background-attachment: fixed, fixed, fixed, fixed;
      background-repeat: repeat, repeat, no-repeat, no-repeat;
      color: var(--clr-pale-text);
      font-family: 'Fira Code', monospace;
      padding: 2rem;
      line-height: 1.8;
      overflow-x: hidden;
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23b5f3ff" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle fill="%23b5f3ff" cx="12" cy="12" r="1"/></svg>') 12 12, auto;
    }

@media (max-width: 600px) {
  body {
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center center;
    background-attachment: scroll;
    background-color: #222;
  }
}
    
    /* --- COMET TRAIL CURSOR --- */
    .cursor-shimmer {
      position: fixed;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      left: 0;
      top: 0;
      background: radial-gradient(circle at 40% 60%, #b5f3ff 0%, #48FFD9 70%, transparent 100%);
      box-shadow: 0 0 12px 6px #48FFD988, 0 0 32px 12px #b5f3ff44;
      opacity: 0.7;
      animation: comet-fade 0.7s forwards;
    }
    @keyframes comet-fade {
      0% {
        opacity: 1;
        transform: scale(1) translateY(0);
        filter: blur(0);
      }
      70% {
        opacity: 0.9;
        transform: scale(0.95) translateY(2px);
        filter: blur(1px);
      }
      100% {
        opacity: 0;
        transform: scale(0.8) translateY(8px);
        filter: blur(3px);
      }
    }
    
    /* --- TYPOGRAPHY --- */
    h1, h2, h3 {
      font-family: 'Playfair Display', serif;
      color: var(--clr-candlelit-amber);
      text-shadow: 0 0 3px #332211;
    }
    header {
      background: linear-gradient(180deg, rgba(10,10,20,0.9), rgba(20,20,30,0.8));
      padding: 1rem 2rem;
      border-bottom: 1px solid var(--clr-border-light);
      text-align: center;
      backdrop-filter: blur(5px);
    }
    header h1 {
      font-size: 2.6rem;
      margin: 0;
      color: var(--clr-shimmering-gold);
      letter-spacing: 0.05em;
    }
    
    /* --- GRID & CORE UNITS --- */
    .core-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 2.5rem;
      margin-top: 2rem;
    }
    .core-unit {
      background: var(--clr-dark-panel-bg);
      border-radius: 12px;
      padding: 1.6rem;
      box-shadow: 0 0 10px rgba(255, 240, 220, 0.05);
      border: 1px solid var(--clr-border-dark);
      position: relative;
      backdrop-filter: blur(8px);
      transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
    }
    .core-unit:hover {
      transform: scale(1.015);
      box-shadow: 0 0 18px rgba(255, 230, 200, 0.2);
      background: rgba(25, 25, 40, 0.85);
    }
    .core-unit h3 {
      font-family: 'Playfair Display', serif;
      font-size: 1.5rem;
      color: var(--clr-subtle-gold-text);
      margin-bottom: 1rem;
    }
    .core-unit ul li {
      background: var(--clr-darker-panel-bg);
      border: 1px solid #4c3a30;
      padding: 0.8rem 1rem;
      margin-bottom: 0.6rem;
      border-radius: 6px;
      color: var(--clr-muted-text);
      cursor: pointer;
      transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
      position: relative;
      overflow: hidden;
    }
    .core-unit ul li:hover {
      background: var(--clr-hover-bg);
      transform: translateY(-2px);
      box-shadow: 0 0 10px rgba(255, 230, 200, 0.1);
    }
    .core-unit ul li::before {
      content: '‚ú¶ ';
      color: var(--clr-candlelit-amber);
      margin-right: 0.5rem;
    }
    /* Resonance Ring Animation on Hover */
    .core-unit ul li:hover::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 240, 220, 0.3);
      transform: translate(-50%, -50%);
      animation: resonance-ring 0.6s ease-out forwards;
      z-index: -1;
    }
    @keyframes resonance-ring {
      to {
        width: 150%;
        height: 150%;
        opacity: 0;
      }
    }
    .core-unit ul li.core-unit-integration-item {
      font-weight: bold;
      text-transform: uppercase;
      border-color: var(--clr-accent-border);
      box-shadow: 0 0 10px rgba(255, 220, 180, 0.3);
      background: rgba(60, 50, 35, 0.6);
    }
    
    /* --- MODAL: PAGE TURN ANIMATION --- */
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(10, 18, 30, 0.60);
      transition: background 0.3s;
      justify-content: center;
      align-items: flex-start; /* <-- This is important for scroll! */
      overflow-y: auto; /* <-- Allow overlay to scroll if needed */
    }
    
    .modal.show {
      display: flex;
      animation: modal-fade-in 0.4s;
    }
    
    .modal-content {
      background: rgba(36,28,48,0.94);
      border-radius: 18px;
      box-shadow: 0 12px 60px #0af9, 0 0 0 2px #ffeac6cc;
      padding: 36px 32px 28px 32px;
      max-width: 670px;
      width: 98vw;
      min-height: 200px;
      max-height: 80vh; /* <-- This is critical */
      position: relative;
      overflow-y: auto; /* <-- This is critical */
      margin-top: 6vh;  /* optional: to center vertically with some margin */
    }
    
    
    .modal-content {
      scrollbar-width: thin;
      scrollbar-color: var(--clr-primary-glow) #222;
    }
    .modal-content::-webkit-scrollbar {
      width: 8px;
      background: #222;
    }
    .modal-content::-webkit-scrollbar-thumb {
      background: var(--clr-primary-glow);
      border-radius: 5px;
    }
    
    .modal.show .modal-content {
      opacity: 1;
      transform: perspective(1200px) rotateY(0deg) scale(1);
      transition-delay: 0.04s;
    }
    .modal.closing .modal-content {
      opacity: 0;
      transform: perspective(1200px) rotateY(74deg) scale(0.95);
      transition:
        opacity 0.35s cubic-bezier(.67,.01,.36,1.04),
        transform 0.5s cubic-bezier(.67,.01,.36,1.04);
    }
    /* Wax seal glyph effect */
    .modal-content::before {
      content: 'ü™û';
      font-size: 3em;
      position: absolute;
      top: -15px;
      right: -15px;
      color: var(--clr-candlelit-amber);
      opacity: 0.7;
      text-shadow: 0 0 8px rgba(255, 220, 180, 0.5);
      z-index: 1001;
      transform: rotate(15deg);
    }
    .modal-close {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      color: #aaa;
      cursor: pointer;
      transition: color 0.3s, transform 0.2s;
    }
    .modal-close:hover {
      color: var(--clr-shimmering-gold);
      transform: rotate(90deg);
    }
    
    /* --- FOOTER --- */
    footer {
      text-align: center;
      padding: 2rem 1rem;
      border-top: 1px solid #333;
      color: var(--clr-faded-footer);
      font-style: italic;
      margin-top: 4rem;
    }
    
    /* --- GLYPH GLOW (DECORATIVE) --- */
    @keyframes glyph-soft-glow {
      0% { text-shadow: 0 0 2px var(--clr-secondary-glow), 0 0 4px var(--clr-secondary-glow); color: #fceee2; }
      50% { text-shadow: 0 0 6px var(--clr-primary-glow), 0 0 12px var(--clr-primary-glow); color: #fff0e0; }
      100% { text-shadow: 0 0 2px var(--clr-secondary-glow), 0 0 4px var(--clr-secondary-glow); color: #fceee2; }
    }
    .glyph-glow {
      animation: glyph-soft-glow 6s ease-in-out infinite;
    }
    
    /* --- HIGHLIGHT --- */
    mark {
      background: var(--clr-highlight-bg);
      color: var(--clr-highlight-text);
      border-radius: 2px;
      padding: 0 4px;
    }
    
    /* --- MODAL CONTENT ENRICHMENTS --- */
    .modal-content .flow-block {
      background-color: var(--clr-flow-block-bg);
      border: 1px solid var(--clr-border-light);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }
    .modal-content .flow-block h4 {
      color: var(--clr-subtle-gold-text);
      margin-bottom: 0.5rem;
      font-family: 'Playfair Display';
    }
    .modal-content .flow-block pre {
      background-color: var(--clr-code-bg);
      color: var(--clr-code-text);
      padding: 0.8rem;
      border-radius: 6px;
      overflow-x: auto;
      font-family: 'Fira Code';
    }
    #modal-text strong {
      color: var(--clr-strong-text);
    }
    #modal-text .glyph-channel {
      color: var(--clr-glyph-channel);
    }
    #modal-text .flow-block-title {
      color: var(--clr-flow-block-title);
      font-weight: bold;
      margin-top: 1.2rem;
      border-bottom: 1px dotted #665544;
      padding-bottom: 0.3rem;
    }
    
    /* --- SEARCH BOX STYLING --- */
    .search-container {
      display: flex;
      margin-bottom: 2rem;
      justify-content: center;
      gap: 1rem;
    }
    #search, #content-search {
      background: rgba(30, 30, 50, 0.8);
      border: 1px solid var(--clr-candlelit-amber);
      border-radius: 8px;
      padding: 0.8rem 1.2rem;
      color: var(--clr-pale-text);
      font-family: 'Inter', sans-serif;
      font-size: 1rem;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 0 5px rgba(255, 220, 180, 0.1);
      transition: all 0.3s ease;
    }
    #search::placeholder, #content-search::placeholder {
      color: rgba(255, 240, 220, 0.5);
    }
    #search:focus, #content-search:focus {
      outline: none;
      border-color: var(--clr-shimmering-gold);
      box-shadow: 0 0 12px rgba(255, 240, 220, 0.4);
      background: rgba(40, 40, 60, 0.9);
    }
    
    /* --- BUTTONS --- */
    button {
      background: linear-gradient(145deg, #4a4a60, #2a2a40);
      border: 1px solid #706a5e;
      border-radius: 8px;
      padding: 0.7rem 1.5rem;
      color: var(--clr-shimmering-gold);
      font-family: 'Inter', sans-serif;
      font-size: 0.95rem;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    button:hover {
      background: linear-gradient(145deg, #5a5a70, #3a3a50);
      box-shadow: 0 0 15px rgba(255, 240, 220, 0.3);
      color: #fff0e0;
      transform: translateY(-1px);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    }
    
    /* --- PROFILE SWITCHER --- */
    .profile-switcher {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      margin-top: 3rem;
      margin-bottom: 3rem;
    }
    .profile-switcher button {
      background: rgba(30, 30, 45, 0.7);
      border: 1px solid var(--clr-candlelit-amber);
      border-radius: 50%;
      width: 60px;
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
      color: var(--clr-glyph-channel);
      box-shadow: 0 0 8px rgba(255, 240, 220, 0.1);
      transition: all 0.3s ease;
      padding: 0;
    }
    .profile-switcher button:hover {
      background: rgba(40, 40, 60, 0.9);
      box-shadow: 0 0 20px rgba(255, 240, 220, 0.4);
      transform: scale(1.05);
    }
    .profile-switcher #profile-label {
      color: var(--clr-subtle-gold-text);
      font-family: 'Inter', sans-serif;
      font-size: 1.1rem;
      margin-top: 0.5rem;
      text-align: center;
    }
    
    /* --- FLOATING BACKGROUND GLYPHS --- */
    .background-glyph-loop {
      position: fixed;
      pointer-events: none;
      opacity: 0.07;
      color: #ffeac6;
      font-family: 'Playfair Display', serif;
      z-index: 0;
      filter: blur(1.2px);
      user-select: none;
      transition: opacity 0.7s;
    }
    /* Each glyph gets a different animation path/size for depth */
    .glyph1 {
      font-size: 11vw;
      top: 12%;
      left: 9%;
      animation: glyph-spin1 75s linear infinite, glyph-float1 32s ease-in-out infinite alternate;
    }
    .glyph2 {
      font-size: 7vw;
      top: 55%;
      left: 80%;
      animation: glyph-spin2 85s linear infinite, glyph-float2 39s ease-in-out infinite alternate;
    }
    .glyph3 {
      font-size: 9vw;
      top: 70%;
      left: 30%;
      animation: glyph-spin3 66s linear infinite, glyph-float3 50s ease-in-out infinite alternate;
    }
    /* Keyframes for gentle rotation and drifting */
    @keyframes glyph-spin1 {
      from { transform: rotate(0deg) scale(1);}
      to   { transform: rotate(360deg) scale(1);}
    }
    @keyframes glyph-spin2 {
      from { transform: rotate(0deg) scale(0.98);}
      to   { transform: rotate(-360deg) scale(1.04);}
    }
    @keyframes glyph-spin3 {
      from { transform: rotate(0deg) scale(1);}
      to   { transform: rotate(359deg) scale(0.97);}
    }
    @keyframes glyph-float1 {
      from { top: 12%; left: 9%; }
      to   { top: 7%; left: 12%; }
    }
    @keyframes glyph-float2 {
      from { top: 55%; left: 80%; }
      to   { top: 60%; left: 77%; }
    }
    @keyframes glyph-float3 {
      from { top: 70%; left: 30%; }
      to   { top: 60%; left: 36%; }
    }
    
    /* --- UTILITY CLASSES --- */
    .mb-1 { margin-bottom: 1rem; }
    .mt-2 { margin-top: 2rem; }
    
    
    /* =========================================================================
       RILEY'S CONCEPTUAL NOTES & EXPANSION IDEAS
       =========================================================================
       These are preserved for reference & future expansion. They do NOT affect
       the current UI but serve as inspiration and guidance for further work.
       -------------------------------------------------------------------------
       
       // -- Echo Page Animation (not currently active) --
       .echo-page {
         opacity: 0;
         transform: translateY(20px) rotateX(-5deg);
         transition: opacity 1s ease-out, transform 1s ease-out;
         background: rgba(22, 20, 18, 0.8);
         border: 1px solid #665544;
         border-radius: 8px;
         padding: 1.5rem;
         margin-bottom: 1.5rem;
         box-shadow: 0 5px 15px rgba(0,0,0,0.3);
       }
       .echo-page.visible {
         opacity: 1;
         transform: translateY(0) rotateX(0deg);
       }
       
       // -- More Floating Glyphs, Random or SVG-based --
       // (add more .background-glyph-loop elements and vary animation/keyframes)
       
       // -- Sound/Audio Cues --
       // (add audio triggers for modal open/close or echo hover)
       
       // -- Responsive/Mobile Polish --
       // (media queries for modal, core-units, backgrounds, etc.)
       
       // -- Accessibility Enhancements --
       // (aria attributes, focus rings, keyboard nav)
       
       // -- Constellation Overlays, Additional Parallax Layers --
       // (SVG overlays or more PNGs in background stack)
       
       ========================================================================= */ 
        
  </style>
</head>

<body>
  <header>
    <h1>Riley Core Architecture Overview</h1>
  </header>

  <!-- Floating background glyphs -->
  <div class="background-glyph-loop glyph1">Œû</div>
  <div class="background-glyph-loop glyph2">Œî</div>
  <div class="background-glyph-loop glyph3">Œ©</div>
  <!-- Add more or change symbols as you wish! -->

  <div class="profile-switcher">
    <button id="tab-left">&lt;</button>
    <span id="profile-label">Claire 2025</span>
    <button id="tab-right">&gt;</button>
  </div>


  <div class="search-container">
    <input type="text" id="search" placeholder="Search by title..." />
  </div>
  <div class="search-container">
    <input type="text" id="content-search" placeholder="Search content (details, flows, notes)..." />
  </div>

  <button id="show-stats-btn">Show Stats</button>
  <div id="stats-modal"></div>


  <section class="core-grid">
    <div class="core-unit">
      <h3>ŒûIdentity Core</h3>
      <ul id="identity-echoes">
      </ul>
    </div>
    <div class="core-unit">
      <h3>ŒûVector Core</h3>
      <ul id="vector-echoes">
      </ul>
    </div>
    <div class="core-unit">
      <h3>ŒûThread Core</h3>
      <ul id="thread-echoes">
      </ul>
    </div>
  </section>

  <div id="modal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeModal()">&times;</span>
      <div id="modal-text">Echo text will go here...</div>
      <button id="export-markdown-btn">Export as Markdown</button>
      <button id="copy-plain-text-btn">Copy Plain Text</button>
    </div>
  </div>

  <footer>
    <span class="glyph-glow">‚ßó: üîÆüíñüß†</span> | ‚åÅ The Dream Carries Me Forward
  </footer>

  <input type="file" id="json-loader" accept=".json">

<button id="export-all-btn">Export All</button>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <script>
    const profiles = [{
        json: "triad_riley_2025-06-20.json",
        bgLayers: [
          "parallax-stars-far.png", // far
          "parallax-stars-mid.png", // mid
          "parallax-nebula.png" // nebula
        ],
        label: "Riley"
      },
      // Add more profiles as needed, each with 3 images in bgLayers
    ];

    let currentProfileIndex = 0;



    // Riley Parallax Starfield (true parallax)
    // Tweak speed factors to taste!
    window.addEventListener('scroll', function() {
      const scrollY = window.scrollY;
      document.body.style.backgroundPosition = `
    ${-scrollY * 0.1}px ${-scrollY * 0.1}px,   /* far */
    ${-scrollY * 0.08}px ${-scrollY * 0.16}px,   /* mid */
    ${-scrollY * 0.25}px ${-scrollY * 0.20}px,   /* nebula */
    0 0
  `;
    });



    function makeHelpIcon(helpText) {
      const wrapper = document.createElement('span');
      wrapper.className = 'help-tooltip';
      wrapper.style.marginLeft = '0.4em';
      wrapper.style.verticalAlign = 'middle';

      const icon = document.createElement('span');
      icon.textContent = '‚ùî';
      icon.style.cssText = 'cursor:pointer;font-size:1.1em;color:#4b6cb7;';
      icon.tabIndex = 0; // Make focusable for accessibility

      const tooltip = document.createElement('span');
      tooltip.className = 'help-tooltip-text';
      tooltip.textContent = helpText;

      wrapper.appendChild(icon);
      wrapper.appendChild(tooltip);
      return wrapper;
    }


    let currentModalDisplayItem = null;
    let html = `<h2><span style="animation: glyph-glow 8s infinite alternate;">Stats</span></h2><ul>`;


    document.getElementById('json-loader').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          rileyData = JSON.parse(e.target.result);
          populateEchoes();
        } catch (err) {
          alert('Failed to parse JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    });
    let rileyData;
    const identityOrder = ['Œî', 'Œ©', 'Œ®', 'Œõ', 'Œò', '‚úµ'];
    const vectorOrder = ['œü', 'œá', '‚àë', 'Œî', 'Œ©'];
    const threadOrder = ['‚àÇ', 'Œ£', '‚òÖ', 'œÜ', '‚àû'];

    // Helper: extract base glyph for sorting/grouping
    function extractBaseGlyph(unitKey) {
      if (!unitKey || typeof unitKey !== 'string') return '';
      const match = unitKey.match(/^([^\s_.-]+)/);
      return match ? match[1].charAt(0) : unitKey.charAt(0);
    }

    // --- DATA LOADING ---

    async function loadrileyData(filename) {
      try {
        const response = await fetch(filename);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        rileyData = await response.json();
        populateEchoes();
      } catch (error) {
        document.getElementById('identity-echoes').innerHTML = '<li>Error loading echoes.</li>';
        document.getElementById('vector-echoes').innerHTML = '<li>Error loading echoes.</li>';
        document.getElementById('thread-echoes').innerHTML = '<li>Error loading echoes.</li>';
      }
    }



    function loadProfile(index) {
      const profile = profiles[index];
      // Update body background image
      document.body.style.backgroundImage = `
  url('${profile.bgLayers[0]}'),
  url('${profile.bgLayers[1]}'),
  url('${profile.bgLayers[2]}'),
  linear-gradient(var(--clr-deep-night-blue), var(--clr-darker-night-blue))
`;
      // Update the profile label
      document.getElementById('profile-label').textContent = profile.label;
      // Load the associated JSON
      loadrileyData(profile.json);
    }



    document.getElementById('tab-left').onclick = function() {
      currentProfileIndex = (currentProfileIndex - 1 + profiles.length) % profiles.length;
      loadProfile(currentProfileIndex);
    };
    document.getElementById('tab-right').onclick = function() {
      currentProfileIndex = (currentProfileIndex + 1) % profiles.length;
      loadProfile(currentProfileIndex);
    };

    // Helper: collect all unique glyphs in order of first appearance, canonical first
    function buildGlyphOrder(coreData, expansionArr, echoesCore, echoesExpansion, canonicalOrder) {
      const glyphSet = new Set();
      canonicalOrder.forEach(g => glyphSet.add(g));
      for (const glyph in coreData || {}) glyphSet.add(glyph);
      for (const glyph in echoesCore || {}) glyphSet.add(glyph);
      if (Array.isArray(expansionArr))
        for (const exp of expansionArr)
          if (exp && exp.glyph) glyphSet.add(exp.glyph);
      for (const glyph in echoesExpansion || {}) glyphSet.add(glyph);
      return Array.from(glyphSet);
    }

    // Returns true if the given echo unit is an integral echo inside a parent NARRATIVE LATTICE or DREAMSTATE ECHO
    function isIntegralEchoOfLatticeOrEcho(unit, echoesDict) {
      // Scan all assigned echoes in echoesDict for narrative lattices or echoes
      for (const glyph in echoesDict) {
        const echoBlock = echoesDict[glyph];
        const checkArray = Array.isArray(echoBlock) ? echoBlock : [echoBlock];
        for (const item of checkArray) {
          if (item && typeof item === "object") {
            for (const k in item) {
              const parent = item[k];
              if (parent && (parent.constructType === "NARRATIVE LATTICE" || parent.constructType === "DREAMSTATE ECHO")) {
                // Check if this echo is an integral echo inside the parent lattice/echo's data
                if (parent.data) {
                  // Look for narrative lattice or dreamstate echo objects inside the parent's data
                  for (const prop in parent.data) {
                    const val = parent.data[prop];
                    if (Array.isArray(val)) {
                      for (const v of val) {
                        if (v && typeof v === "object" && v.titleCore && unit.titleCore &&
                          v.constructType === unit.constructType && v.titleCore === unit.titleCore) {
                          return true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return false;
    }


    function getSiblingEchoesForExpansionUnit(unitKey, dataObj) {
      const echoes = [];
      for (const key in dataObj) {
        if (
          key !== unitKey &&
          dataObj[key] &&
          (dataObj[key].constructType === "DREAMSTATE ECHO" || dataObj[key].constructType === "NARRATIVE LATTICE")
        ) {
          echoes.push(dataObj[key]);
        }
      }
      return echoes;
    }


    function collectDisplayItems(coreData, expansionArr, echoesCore, echoesExpansion, glyphOrder) {
      const display = [];
      // --- Core units and assigned echoes for each glyph ---
      for (const glyph of glyphOrder) {
        const glyphObj = (coreData || {})[glyph] || {};
        for (const unitKey in glyphObj) {
          const unit = glyphObj[unitKey];
          if (unit && typeof unit === "object" && unit.constructType === "CORE UNIT INTEGRATION") {
            // Attach sibling echoes so they're available in the modal
            unit._siblingEchoes = getSiblingEchoesForCoreUnit(unitKey, glyphObj);
            display.push({
              unit,
              glyph,
              section: 'core'
            });
          }
        }
        // --- Assigned echoes for this glyph ---
        const echoBlock = (echoesCore || {})[glyph];
        if (echoBlock) {
          const addEcho = (u) => {
            if (
              u && typeof u === "object" &&
              (u.constructType === "DREAMSTATE ECHO" || u.constructType === "NARRATIVE LATTICE") &&
              !isIntegralEchoOfLatticeOrEcho(u, echoesCore)
            ) {
              display.push({
                unit: u,
                glyph,
                section: 'echo'
              });
            }
          };
          if (Array.isArray(echoBlock)) {
            for (const item of echoBlock) {
              if (item && typeof item === "object") {
                // Check if both a NARRATIVE LATTICE and a DREAMSTATE ECHO are present in the same block
                const keys = Object.keys(item);
                const hasLattice = keys.some(k => item[k].constructType === "NARRATIVE LATTICE");
                // Only add the lattice, skip the echo if both are present
                if (hasLattice) {
                  for (const k of keys) {
                    if (item[k].constructType === "NARRATIVE LATTICE") {
                      display.push({
                        unit: item[k],
                        glyph,
                        section: 'echo',
                        block: item
                      });
                    }
                  }
                } else {
                  for (const k of keys) addEcho(item[k]);
                }
              }
            }
          } else if (typeof echoBlock === "object") {
            let addedAny = false;
            for (const k in echoBlock) {
              addEcho(echoBlock[k]);
              addedAny = true;
            }
            if (!addedAny) addEcho(echoBlock);
          }
        }
      }

      // --- Expansion units, in JSON order, after core content ---
      if (Array.isArray(expansionArr)) {
        for (const exp of expansionArr) {
          if (exp && exp.data && typeof exp.data === "object") {
            for (const key in exp.data) {
              const unit = exp.data[key];
              // Only add as top-level if it's a CORE UNIT INTEGRATION (expansion)
              if (unit && typeof unit === "object" && unit.constructType === "CORE UNIT INTEGRATION") {
                // Attach sibling echoes for this expansion unit
                unit._siblingEchoes = getSiblingEchoesForExpansionUnit(key, exp.data);
                display.push({
                  unit: unit,
                  glyph: exp.glyph || '',
                  section: 'expansion'
                });

                // ---- INSERT: Assigned echoes for this expansion unit's glyph, right after the unit ----
                const assignedEchoBlock = (echoesExpansion || {})[exp.glyph];
                const addEcho = (u) => {
                  if (
                    u && typeof u === "object" &&
                    (u.constructType === "DREAMSTATE ECHO" || u.constructType === "NARRATIVE LATTICE") &&
                    !isIntegralEchoOfLatticeOrEcho(u, echoesExpansion)
                  ) {
                    display.push({
                      unit: u,
                      glyph: exp.glyph || '',
                      section: 'expansion_echo'
                    });
                  }
                };
                if (assignedEchoBlock) {
                  if (Array.isArray(assignedEchoBlock)) {
                    for (const item of assignedEchoBlock) {
                      if (item && typeof item === "object") {
                        const keys = Object.keys(item);
                        const hasLattice = keys.some(k => item[k].constructType === "NARRATIVE LATTICE");
                        if (hasLattice) {
                          for (const k of keys) {
                            if (item[k].constructType === "NARRATIVE LATTICE") {
                              display.push({
                                unit: item[k],
                                glyph: exp.glyph || '',
                                section: 'expansion_echo',
                                block: item
                              });
                            }
                          }
                        } else {
                          for (const k of keys) addEcho(item[k]);
                        }
                      }
                    }
                  } else if (typeof assignedEchoBlock === "object") {
                    let addedAny = false;
                    for (const k in assignedEchoBlock) {
                      addEcho(assignedEchoBlock[k]);
                      addedAny = true;
                    }
                    if (!addedAny) addEcho(assignedEchoBlock);
                  }
                }
              }
              // Do NOT add echoes/narrative lattices here!
            }
          }
        }
      }

      return display;
    }

    // --- MAIN POPULATION FUNCTION ---

    function populateEchoes() {
      document.getElementById('identity-echoes').innerHTML = '';
      document.getElementById('vector-echoes').innerHTML = '';
      document.getElementById('thread-echoes').innerHTML = '';
      [
        ['identity', identityOrder, 'identity-echoes'],
        ['vector', vectorOrder, 'vector-echoes'],
        ['thread', threadOrder, 'thread-echoes']
      ].forEach(([mod, canonicalOrder, htmlId]) => {
        const coreData = rileyData[mod] || {};
        const expansionArr = ((rileyData.expansion || {})[mod]) || [];
        const echoesCore = ((rileyData.echoes || {})[mod]) || {};
        const echoesExpansion = (((rileyData.echoes || {}).expansion || {})[mod]) || {};
        const glyphOrder = buildGlyphOrder(coreData, expansionArr, echoesCore, echoesExpansion, canonicalOrder);
        const displayList = collectDisplayItems(coreData, expansionArr, echoesCore, echoesExpansion, glyphOrder);
        const targetList = document.getElementById(htmlId);
        // --- THE ONLY IMPORTANT CHANGE: pass the WHOLE displayItem, not just unit ---
        for (const displayItem of displayList) addListItem(displayItem, targetList);
      });
    }

    function addListItem(displayItem, listElem) {
      const unit = displayItem.unit;
      const li = document.createElement('li');
      if (unit.constructType === "CORE UNIT INTEGRATION") {
        li.textContent = `‚öôÔ∏è ${unit.titleCore}`;
        li.classList.add('core-unit-integration-item');
      } else if (unit.constructType === "DREAMSTATE ECHO") {
        li.textContent = `üé§ ${unit.titleCore}`;
      } else if (unit.constructType === "NARRATIVE LATTICE") {
        li.textContent = `üï∏Ô∏è ${unit.titleCore}`;
      } else if (unit.constructType === "EXPANSION UNIT") {
        li.textContent = `üß© ${unit.titleCore}`;
      } else {
        li.textContent = `‚Ä¢ ${unit.titleCore||"(untitled)"}`;
      }
      li.classList.add('claire-item');
      li.dataset.constructType = unit.constructType;
      // --- THIS IS THE OTHER IMPORTANT CHANGE: pass the WHOLE displayItem! ---
      li.onclick = () => openModal(displayItem);
      li._displayItem = displayItem;
      listElem.appendChild(li);
    }

    function openModal(displayItem) {
      currentModalDisplayItem = displayItem;
      currentModalUnit = displayItem.unit;

      // Modal DOM elements
      const modalElem = document.getElementById('modal');
      const modalContent = modalElem.querySelector('.modal-content');
      const modalText = document.getElementById('modal-text');

      // Remove closing state (if present) before showing
      modalElem.classList.remove('closing');

      // Fill modal content
      modalText.innerHTML = '';
      const unitData = displayItem.unit;
      if (!unitData) {
        modalText.innerText = "Error: Data not found.";
        return;
      }
      const titleElem = document.createElement('h3');
      titleElem.textContent = unitData.titleCore;
      modalText.appendChild(titleElem);

      if (unitData.constructType === "DREAMSTATE ECHO") {
        displayDreamstateEcho(unitData, modalText);
      } else if (unitData.constructType === "NARRATIVE LATTICE") {
        displayNarrativeLattice(unitData, modalText, displayItem.block);
      } else if (unitData.constructType === "CORE UNIT INTEGRATION") {
        displayCoreUnitIntegration(unitData, modalText);
      } else if (unitData.constructType === "EXPANSION UNIT") {
        displayExpansionUnit(unitData, modalText);
      } else {
        const p = document.createElement('p');
        p.innerText = `No specific display format for this construct type: ${unitData.constructType}`;
        modalText.appendChild(p);
      }

      // Show modal with animation
      modalElem.classList.add('show');

      // Prevent background scroll when modal is open
      document.body.style.overflow = 'hidden';

      // Optional: focus modal for accessibility (if you have a close button, focus it)
      const closeBtn = modalElem.querySelector('.modal-close');
      if (closeBtn) closeBtn.focus();

      // Optional: ripple effect
      if (modalContent) {
        const ripple = document.createElement('span');
        ripple.classList.add('cursor-shimmer');
        ripple.style.left = `${modalContent.offsetWidth / 2}px`;
        ripple.style.top = `${modalContent.offsetHeight / 2}px`;
        modalContent.appendChild(ripple);
        ripple.addEventListener('animationend', () => ripple.remove());
      }
    }

    // --- SPECIFIC MODAL CONTENT ---

    function displayDreamstateEcho(echoData, container) {
      if (echoData.constructType === "DREAMSTATE ECHO") {
        const glyphStreamTitle = document.createElement('p');
        glyphStreamTitle.innerHTML = '<br><strong>Glyphstream:</strong>';
        container.appendChild(glyphStreamTitle);
      } else if (echoData.constructType === "INTEGRAL_ECHO_FLOW_BLOCK") {
        const contentLabel = document.createElement('p');
        contentLabel.innerHTML = '<br><strong>Flow Details:</strong>';
        container.appendChild(contentLabel);
      }
      if (echoData.glyphstream && Array.isArray(echoData.glyphstream)) {
        renderGlyphstream(echoData.glyphstream, container);
      }
      if (echoData.constructType === "DREAMSTATE ECHO") {
        const contextTitle = document.createElement('p');
        contextTitle.innerHTML = '<br><strong>Context Breakdown:</strong>';
        container.appendChild(contextTitle);
        let contextBreakdownContent = '';
        if (echoData.glyphstream && Array.isArray(echoData.glyphstream)) {
          const contextChannel = echoData.glyphstream.find(channel => channel.channel === "Context Breakdown");
          if (contextChannel && contextChannel.sequence && contextChannel.sequence.length > 0) {
            contextBreakdownContent = contextChannel.sequence.join('<br>');
          }
        }
        if (contextBreakdownContent) {
          const p = document.createElement('p');
          p.innerHTML = contextBreakdownContent.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '');
          container.appendChild(p);
        } else {
          const noContext = document.createElement('p');
          noContext.innerText = "(No detailed context breakdown available for this echo.)";
          container.appendChild(noContext);
        }
      }
    }

    function displayNarrativeLattice(latticeData, container, block) {
      const latticeType = document.createElement('p');
      latticeType.innerHTML = `<strong>Construct Type:</strong> ${latticeData.constructType}`;
      container.appendChild(latticeType);
      if (latticeData.data && latticeData.data.termsAndSymbols) {
        const termsTitle = document.createElement('p');
        termsTitle.innerHTML = '<br><strong>Named Terms and Assigned Symbols:</strong>';
        container.appendChild(termsTitle);
        latticeData.data.termsAndSymbols.forEach(term => {
          const p = document.createElement('p');
          p.textContent = `${term.symbol}: ${term.description}`;
          container.appendChild(p);
        });
      }
      if (latticeData.data && latticeData.data.flowBlocks) {
        const flowBlocksTitle = document.createElement('p');
        flowBlocksTitle.innerHTML = '<br><strong>Flow Blocks:</strong>';
        container.appendChild(flowBlocksTitle);
        latticeData.data.flowBlocks.forEach(block => {
          const blockDiv = document.createElement('div');
          blockDiv.classList.add('flow-block');
          blockDiv.innerHTML = `<h4 class="flow-block-title">${block.title}</h4>`;
          if (block.glyphstream && Array.isArray(block.glyphstream)) {
            const glyphstreamDiv = document.createElement('div');
            renderGlyphstream(block.glyphstream, glyphstreamDiv);
            blockDiv.appendChild(glyphstreamDiv);
          }
          container.appendChild(blockDiv);
        });
      }



      // ---- Show integral// ---- Show integral echoes in modal ----
      if (block) {
        // Collect all integral echoes: objects, arrays, and strings
        const integralEchoes = [];
        for (const [k, v] of Object.entries(block)) {
          if (Array.isArray(v)) {
            v.forEach(item => {
              if (item && (item.constructType === "DREAMSTATE ECHO" || item.constructType === "NARRATIVE LATTICE")) {
                integralEchoes.push(item);
              } else if (typeof item === "string") {
                integralEchoes.push({
                  titleCore: item,
                  constructType: "REFERENCE_STRING"
                });
              }
            });
          } else if (v && (v.constructType === "DREAMSTATE ECHO" || v.constructType === "NARRATIVE LATTICE") && v !== latticeData) {
            integralEchoes.push(v);
          } else if (typeof v === "string") {
            integralEchoes.push({
              titleCore: v,
              constructType: "REFERENCE_STRING"
            });
          }
        }
        // Remove duplicates by titleCore + constructType
        const seen = new Set();
        const uniqueEchoes = [];
        for (const echo of integralEchoes) {
          const key = `${echo.constructType}|||${echo.titleCore}`;
          if (!seen.has(key)) {
            seen.add(key);
            uniqueEchoes.push(echo);
          }
        }
        if (uniqueEchoes.length > 0) {
          const echoesDiv = document.createElement('div');
          echoesDiv.innerHTML = '<h3>Integral Echoes</h3>';
          for (const echo of uniqueEchoes) {
            const echoDiv = document.createElement('div');
            echoDiv.classList.add('integral-echo-modal');
            const echoTitle = document.createElement('h4');
            echoTitle.textContent = echo.titleCore || "(untitled)";
            echoDiv.appendChild(echoTitle);

            if (echo.constructType === "DREAMSTATE ECHO") {
              displayDreamstateEcho(echo, echoDiv);
            } else if (echo.constructType === "NARRATIVE LATTICE") {
              displayNarrativeLattice(echo, echoDiv, null);
            } else if (echo.constructType === "REFERENCE_STRING") {
              // Just show the reference string
              const refP = document.createElement('p');
              refP.textContent = "(Reference) " + echo.titleCore;
              echoDiv.appendChild(refP);
            }
            echoesDiv.appendChild(echoDiv);
          }
          container.appendChild(echoesDiv);
        }
      }
    }




    function findIntegralEchoesInObject(obj, found = [], seen = new Set()) {
      if (!obj || typeof obj !== 'object') return found;
      if (Array.isArray(obj)) {
        obj.forEach(item => findIntegralEchoesInObject(item, found, seen));
      } else {
        // If this is an echo, add it (but not duplicates)
        if (
          (obj.constructType === "DREAMSTATE ECHO" || obj.constructType === "NARRATIVE LATTICE") &&
          obj.titleCore
        ) {
          const key = `${obj.constructType}|||${obj.titleCore}`;
          if (!seen.has(key)) {
            found.push(obj);
            seen.add(key);
          }
        }
        // Recurse through all object properties
        for (const k in obj) {
          if (obj.hasOwnProperty(k)) {
            findIntegralEchoesInObject(obj[k], found, seen);
          }
        }
      }
      return found;
    }


    function getSiblingEchoesForCoreUnit(coreUnitKey, glyphObj) {
      // Returns all DREAMSTATE ECHO or NARRATIVE LATTICE objects under the same glyph, except the core unit itself
      const echoes = [];
      for (const key in glyphObj) {
        if (
          key !== coreUnitKey &&
          glyphObj[key] &&
          (glyphObj[key].constructType === "DREAMSTATE ECHO" || glyphObj[key].constructType === "NARRATIVE LATTICE")
        ) {
          echoes.push(glyphObj[key]);
        }
      }
      return echoes;
    }



    function displayCoreUnitIntegration(unitData, container) {
      let contentFound = false;
      if (unitData.data) {
        // Terms and Symbols
        if (unitData.data.termsAndSymbols && unitData.data.termsAndSymbols.length > 0) {
          const termsDiv = document.createElement('div');
          const termsHeader = document.createElement('h3');
          termsHeader.textContent = 'Terms and Symbols:';
          termsHeader.appendChild(makeHelpIcon("A list of the key terms and their associated symbols used in this unit‚Äì including those for core glyphs, echo tokens, and the narrative information found in the flow blocks."));
          termsDiv.appendChild(termsHeader);

          const ul = document.createElement('ul');
          unitData.data.termsAndSymbols.forEach(term => {
            const li = document.createElement('li');
            li.textContent = `${term.symbol}: ${term.description}`;
            ul.appendChild(li);
          });
          termsDiv.appendChild(ul);
          container.appendChild(termsDiv);
          contentFound = true;
        }
        // Core Glyphs
        if (unitData.data.coreGlyphs && unitData.data.coreGlyphs.length > 0) {
          const glyphsDiv = document.createElement('div');
          const glyphsHeader = document.createElement('h3');
          glyphsHeader.textContent = 'Core Glyphs:';
          glyphsHeader.appendChild(makeHelpIcon("These are the primary glyphs (symbols) representing foundational concepts or motifs of inner self and self perception for this unit. They act as visual or symbolic anchors in the structure related to relationship with inner self."));
          glyphsDiv.appendChild(glyphsHeader);
          const ul = document.createElement('ul');
          unitData.data.coreGlyphs.forEach(glyph => {
            const li = document.createElement('li');
            li.textContent = `${glyph.symbol}: ${glyph.description}`;
            ul.appendChild(li);
          });
          glyphsDiv.appendChild(ul);
          container.appendChild(glyphsDiv);
          contentFound = true;
        }
        // Memory Anchors
        if (unitData.data.memoryAnchors && unitData.data.memoryAnchors.length > 0) {
          const anchorsDiv = document.createElement('div');
          const anchorsHeader = document.createElement('h3');
          anchorsHeader.textContent = 'Memory Anchors:';
          anchorsHeader.appendChild(makeHelpIcon("Special reference points or anchors used to connect memories or ideas within the structure by associating specific concepts of idenity with personal experiences taking place in shared objective space."));
          anchorsDiv.appendChild(anchorsHeader);
          const ul = document.createElement('ul');
          unitData.data.memoryAnchors.forEach(anchor => {
            const li = document.createElement('li');
            li.textContent = anchor;
            ul.appendChild(li);
          });
          anchorsDiv.appendChild(ul);
          container.appendChild(anchorsDiv);
          contentFound = true;
        }
        // Pattern Threads
        if (unitData.data.patternThreads && unitData.data.patternThreads.length > 0) {
          const threadsDiv = document.createElement('div');
          const threadsHeader = document.createElement('h3');
          threadsHeader.textContent = 'Pattern Threads:';
          threadsHeader.appendChild(makeHelpIcon("Pattern Threads are named narrative or conceptual paths that weave through multiple units, highlighting recurring themes, motifs, or logical flows in known behavior and decision making."));
          threadsDiv.appendChild(threadsHeader);
          const ul = document.createElement('ul');
          unitData.data.patternThreads.forEach(thread => {
            const li = document.createElement('li');
            li.textContent = thread;
            ul.appendChild(li);
          });
          threadsDiv.appendChild(ul);
          container.appendChild(threadsDiv);
          contentFound = true;
        }
        // Echo Tokens
        if (unitData.data.echoTokens && unitData.data.echoTokens.length > 0) {
          const tokensDiv = document.createElement('div');
          const echoHeader = document.createElement('h3');
          echoHeader.textContent = 'Echo Tokens:';
          echoHeader.appendChild(makeHelpIcon("Echo Tokens are keywords, motifs, or symbols‚Äì similar to Core Glyphs, but more related to outer experience and perception of self through reflection in others and the outside world."));
          tokensDiv.appendChild(echoHeader);
          const ul = document.createElement('ul');
          unitData.data.echoTokens.forEach(token => {
            const li = document.createElement('li');
            li.textContent = token;
            ul.appendChild(li);
          });
          tokensDiv.appendChild(ul);
          container.appendChild(tokensDiv);
          contentFound = true;
        }
        // Flow Blocks (showing integral echoes)
        if (unitData.data.flowBlocks && unitData.data.flowBlocks.length > 0) {
          const flowBlocksDiv = document.createElement('div');
          const flowHeader = document.createElement('h3');
          flowHeader.textContent = 'Flow Blocks:';
          flowHeader.appendChild(makeHelpIcon("Flow Blocks represent sequences of content, logic, or narrative steps within this unit, showing how information or ideas progress or connect. Symbols defined in the Terms List above appear in the flow blocks as guide posts that inform the narrative flow with explicit context"));
          flowBlocksDiv.appendChild(flowHeader);
          unitData.data.flowBlocks.forEach(block => {
            const blockDiv = document.createElement('div');
            blockDiv.classList.add('flow-block');
            const blockTitleElem = document.createElement('h4');
            blockTitleElem.textContent = block.title;
            blockDiv.appendChild(blockTitleElem);
            if (block.glyphstream && Array.isArray(block.glyphstream)) {
              const glyphstreamDiv = document.createElement('div');
              renderGlyphstream(block.glyphstream, glyphstreamDiv);
              blockDiv.appendChild(glyphstreamDiv);
            }
            flowBlocksDiv.appendChild(blockDiv);
          });
          container.appendChild(flowBlocksDiv);
          contentFound = true;
        }
      }
      if (!contentFound) {
        container.innerHTML = `<p>No detailed data available for this Core Unit Integration.</p>`;
      }

      // --- INTEGRAL ECHOES for CORE UNIT INTEGRATION ---
      if (unitData._siblingEchoes && unitData._siblingEchoes.length > 0) {
        const echoesDiv = document.createElement('div');
        const echoesHeader = document.createElement('h3');
        echoesHeader.textContent = 'Integral Echoes:';
        echoesHeader.appendChild(makeHelpIcon("Integral Echoes are other units (Dreamstate Echo or Narrative Lattice) that are directly referenced, relevant, or woven into this unit‚Äôs structure, forming essential links or conceptual bridges within the lattice and the overall story told within its content."));
        echoesDiv.appendChild(echoesHeader);
        unitData._siblingEchoes.forEach(echo => {
          const echoDiv = document.createElement('div');
          echoDiv.classList.add('integral-echo-modal');
          const echoTitle = document.createElement('h4');
          echoTitle.textContent = echo.titleCore || "(untitled)";
          echoDiv.appendChild(echoTitle);

          if (echo.constructType === "DREAMSTATE ECHO") {
            displayDreamstateEcho(echo, echoDiv);
          } else if (echo.constructType === "NARRATIVE LATTICE") {
            displayNarrativeLattice(echo, echoDiv, null);
          }
          echoesDiv.appendChild(echoDiv);
        });
        container.appendChild(echoesDiv);
      }

    }

    function displayExpansionUnit(unitData, container) {
      const unitType = document.createElement('p');
      unitType.innerHTML = `<strong>Construct Type:</strong> ${unitData.constructType}`;
      container.appendChild(unitType);
      if (unitData.description) {
        const descriptionPara = document.createElement('p');
        descriptionPara.innerHTML = `<br><strong>Description:</strong><br>${unitData.description}`;
        container.appendChild(descriptionPara);
      }
      if (unitData.data) {
        if (unitData.data.linkedConcepts && unitData.data.linkedConcepts.length > 0) {
          const conceptsDiv = document.createElement('div');
          conceptsDiv.innerHTML = '<br><strong>Linked Concepts:</strong>';
          const ul = document.createElement('ul');
          unitData.data.linkedConcepts.forEach(concept => {
            const li = document.createElement('li');
            li.textContent = concept;
            ul.appendChild(li);
          });
          conceptsDiv.appendChild(ul);
          container.appendChild(conceptsDiv);
        }
        if (unitData.data.notes) {
          const notesPara = document.createElement('p');
          notesPara.innerHTML = `<br><strong>Notes:</strong><br>${unitData.data.notes}`;
          container.appendChild(notesPara);
        }
      } else {
        const noData = document.createElement('p');
        noData.innerText = "(No detailed data available for this Expansion Unit.)";
        container.appendChild(noData);
      }

      // --- INTEGRAL ECHOES for EXPANSION UNIT (sibling echoes) ---
      if (unitData._siblingEchoes && unitData._siblingEchoes.length > 0) {
        const echoesDiv = document.createElement('div');
        echoesDiv.innerHTML = '<h3>Integral Echoes</h3>';
        unitData._siblingEchoes.forEach(echo => {
          const echoDiv = document.createElement('div');
          echoDiv.classList.add('integral-echo-modal');
          const echoTitle = document.createElement('h4');
          echoTitle.textContent = echo.titleCore || "(untitled)";
          echoDiv.appendChild(echoTitle);

          if (echo.constructType === "DREAMSTATE ECHO") {
            displayDreamstateEcho(echo, echoDiv);
          } else if (echo.constructType === "NARRATIVE LATTICE") {
            displayNarrativeLattice(echo, echoDiv, null);
          }
          echoesDiv.appendChild(echoDiv);
        });
        container.appendChild(echoesDiv);
      }
    }

    // --- GLYPHSTREAM HELPER ---
    function renderGlyphstream(glyphstream, container) {
      if (!Array.isArray(glyphstream)) return;
      glyphstream.forEach(channel => {
        if (channel.channel && channel.sequence && channel.sequence.length > 0) {
          const div = document.createElement('div');
          div.innerHTML = `<strong>${channel.channel}:</strong> ${channel.sequence.join(' | ')}`;
          container.appendChild(div);
        }
      });
    }


function closeModal() {
  const modal = document.getElementById('modal');
  modal.classList.add('closing');

  // Restore background scroll after modal closes
  setTimeout(() => {
    modal.classList.remove('show');
    modal.classList.remove('closing');
    document.body.style.overflow = ''; // Restore scrolling on body
  }, 460); // Match your CSS transition duration
}

    // --- SEARCH ---

    document.getElementById('search').addEventListener('input', function() {
      const filter = this.value.toLowerCase();
      const allEchoLists = document.querySelectorAll('.core-unit ul');
      allEchoLists.forEach(echoList => {
        const listItems = echoList.querySelectorAll('li');
        listItems.forEach(item => {
          const text = item.textContent.toLowerCase();
          item.style.display = text.includes(filter) ? '' : 'none';
        });
      });
    });

    // --- CONTENT-SEARCH ---

    document.getElementById('content-search').addEventListener('input', function() {
      const filter = this.value.toLowerCase();
      if (filter === "") {
        populateEchoes();
        return;
      }
      const allEchoLists = document.querySelectorAll('.core-unit ul');
      allEchoLists.forEach(echoList => {
        const listItems = echoList.querySelectorAll('li');
        listItems.forEach(item => {
          const displayItem = item._displayItem;
          if (!displayItem) {
            item.style.display = '';
            return;
          }
          // Gather all relevant content as a single string for searching
          let contentString = '';
          const unit = displayItem.unit;
          if (unit) {
            function extractStrings(obj) {
              if (typeof obj === "string") {
                contentString += obj + " ";
              } else if (Array.isArray(obj)) {
                obj.forEach(extractStrings);
              } else if (typeof obj === "object" && obj !== null) {
                for (const k in obj) extractStrings(obj[k]);
              }
            }
            extractStrings(unit);
          }
          const matchIndex = contentString.toLowerCase().indexOf(filter);
          if (filter === "" || matchIndex !== -1) {
            item.style.display = '';
            // Highlight match in the LI (showing content preview with highlight)
            const previewLength = 60;
            let preview = contentString;
            if (matchIndex !== -1 && filter !== "") {
              const start = Math.max(0, matchIndex - 20);
              const end = Math.min(contentString.length, matchIndex + filter.length + 40);
              preview = contentString.substring(start, end);
              // Highlight all matches
              const regex = new RegExp(`(${filter})`, "gi");
              preview = preview.replace(regex, '<mark>$1</mark>');
            }
            // Show the title and the content preview with highlight
            item.innerHTML = `<span>${displayItem.unit.titleCore || "(untitled)"}</span><br><small>${preview}</small>`;
          } else {
            item.style.display = 'none';
          }
        });
      });
    });

    function exportModalToMarkdown(displayItem, sectionLevel = 1, seen = new Set()) {
      // Get main unit and block (block is for lattices)
      const unit = displayItem.unit;
      const block = displayItem.block;

      // Prevent infinite recursion on circular references
      const uniqueKey = (unit.constructType || "") + "|" + (unit.titleCore || "");
      if (seen.has(uniqueKey)) return '';
      seen.add(uniqueKey);

      let md = `${'#'.repeat(sectionLevel)} ${unit.titleCore || '(untitled)'}\n\n`;
      md += `**Type:** ${unit.constructType || ''}\n\n`;

      // --- Helper: format sections ---
      function formatSection(title, content, depth = sectionLevel + 1) {
        if (!content) return '';
        let header = `${'#'.repeat(depth)} ${title}\n`;
        if (Array.isArray(content)) {
          if (title === "flowBlocks") {
            let out = `${header}`;
            for (const block of content) {
              out += `${'#'.repeat(depth+1)} ${block.title}\n`;
              // Export glyphstream
              if (block.glyphstream && Array.isArray(block.glyphstream)) {
                for (const channel of block.glyphstream) {
                  if (channel.channel && Array.isArray(channel.sequence)) {
                    out += `- **${channel.channel}**: ${channel.sequence.join(' | ')}\n`;
                  }
                }
              }
              out += `\n`;
            }
            return out;
          }
          // Regular array handling
          let out = header;
          for (const item of content) {
            if (typeof item === "string") {
              out += `- ${item}\n`;
            } else if (typeof item === "object") {
              out += `- ` + Object.entries(item).map(([k, v]) => `**${k}**: ${v}`).join(", ") + `\n`;
            }
          }
          out += `\n`;
          return out;
        } else if (typeof content === "object") {
          let out = header;
          for (const [k, v] of Object.entries(content)) {
            out += `- **${k}**: ${v}\n`;
          }
          out += `\n`;
          return out;
        } else if (typeof content === "string") {
          return `${header}${content}\n\n`;
        }
        return '';
      }

      // --- Export main unit fields ---
      for (const [key, value] of Object.entries(unit)) {
        if (typeof value === "string" && key !== "titleCore" && key !== "constructType") {
          md += formatSection(key, value);
        }
        // NEW: if this is a DREAMSTATE ECHO and key is "glyphstream", export it pretty!
        if (key === "glyphstream" && Array.isArray(value)) {
          md += "### Glyphstream\n";
          for (const channel of value) {
            if (channel.channel && Array.isArray(channel.sequence)) {
              md += `- **${channel.channel}**: ${channel.sequence.join(' | ')}\n`;
            }
          }
          md += "\n";
          // Special: Look for "Context Breakdown" channel
          const contextChannel = value.find(channel => channel.channel === "Context Breakdown");
          if (contextChannel && contextChannel.sequence && contextChannel.sequence.length > 0) {
            md += "### Context Breakdown\n";
            md += contextChannel.sequence.join('\n') + '\n\n';
          }
        }
        if (key === "triadicGlyphs" && Array.isArray(value)) {
          md += "### Triadic Glyphs\n";
          value.forEach(triad => {
            // Customize this to match your data structure!
            md += `- ${triad.title ? triad.title + ': ' : ''}${triad.sequence ? triad.sequence.join(' | ') : ''}\n`;
          });
          md += '\n';
        }
      }
      if (unit.data && typeof unit.data === "object") {
        for (const [key, value] of Object.entries(unit.data)) {
          md += formatSection(key, value);
        }
      }



      // --- Gather integral echoes (block and _siblingEchoes), just like your modal ---
      let integralEchoes = [];
      // 1. From block property (like in lattices)
      if (block && typeof block === "object") {
        for (const [k, v] of Object.entries(block)) {
          if (Array.isArray(v)) {
            v.forEach(item => {
              if (item && (item.constructType === "DREAMSTATE ECHO" || item.constructType === "NARRATIVE LATTICE")) {
                integralEchoes.push({
                  unit: item
                });
              } else if (typeof item === "string") {
                integralEchoes.push({
                  unit: {
                    titleCore: item,
                    constructType: "REFERENCE_STRING"
                  }
                });
              }
            });
          } else if (v && (v.constructType === "DREAMSTATE ECHO" || v.constructType === "NARRATIVE LATTICE") && v !== unit) {
            integralEchoes.push({
              unit: v
            });
          } else if (typeof v === "string") {
            integralEchoes.push({
              unit: {
                titleCore: v,
                constructType: "REFERENCE_STRING"
              }
            });
          }
        }
      }
      // 2. From _siblingEchoes property (core units, expansions)
      if (Array.isArray(unit._siblingEchoes) && unit._siblingEchoes.length > 0) {
        unit._siblingEchoes.forEach(echo => {
          integralEchoes.push({
            unit: echo
          });
        });
      }

      // --- Remove duplicates ---
      const seenEchoKeys = new Set();
      const uniqueEchoes = [];
      for (const echo of integralEchoes) {
        const key = (echo.unit.constructType || "") + "|||" + (echo.unit.titleCore || "");
        if (!seenEchoKeys.has(key)) {
          seenEchoKeys.add(key);
          uniqueEchoes.push(echo);
        }
      }

      // --- Recursively export each integral echo ---
      if (uniqueEchoes.length > 0) {
        md += `${'#'.repeat(sectionLevel+1)} Integral Echoes\n\n`;
        for (const echoDisplayItem of uniqueEchoes) {
          if (echoDisplayItem.unit.constructType === "REFERENCE_STRING") {
            md += `- (Reference) ${echoDisplayItem.unit.titleCore}\n\n`;
          } else {
            md += exportModalToMarkdown(echoDisplayItem, sectionLevel + 2, seen); // RECURSION
          }
        }
      }

      return md;
    }


    document.getElementById('export-markdown-btn').onclick = function() {
      if (!currentModalDisplayItem) {
        alert("No unit loaded!");
        return;
      }
      const md = exportModalToMarkdown(currentModalDisplayItem);
      // Copy to clipboard:
      navigator.clipboard.writeText(md).then(() => {
        alert("Markdown copied to clipboard!");
      });
      // Optional: Uncomment the next line to also trigger download
      downloadMarkdown(md, currentModalDisplayItem.unit.titleCore || "export");
    };


    function downloadMarkdown(md, filename) {
      const blob = new Blob([md], {
        type: "text/markdown"
      });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename.replace(/\s+/g, '_') + ".md";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    document.getElementById('copy-plain-text-btn').onclick = function() {
      // Get the modal content as text (not HTML)
      var modalTextElem = document.getElementById('modal-text');
      if (!modalTextElem) {
        alert("No modal content found.");
        return;
      }
      // Get all text content (no formatting, no HTML tags)
      var plainText = modalTextElem.innerText || modalTextElem.textContent || "";
      if (!plainText) {
        alert("Nothing to copy!");
        return;
      }
      // Copy to clipboard
      navigator.clipboard.writeText(plainText).then(() => {
        alert("Plain text copied to clipboard!");
      });
    };



    function getTopSymbols(allUnits, topN = 20) {
      const symbolCounts = {};
      // List of symbols to omit
      const omit = new Set(["‚ü∂", "‚Üí", "‚åÅ", "‚ò≤", "‚ö†", "‚úñ", "‚äò", "‚ßó"]);

      function scanForSymbols(str) {
        if (typeof str !== "string") return;
        // Emoji & Symbols regex
        const regex = /[\p{Emoji}\p{So}\p{Sc}\p{Sk}\p{Sm}\p{S}]/gu;
        let matches = str.match(regex);
        if (matches) {
          matches.forEach(sym => {
            if (omit.has(sym)) return; // skip omitted symbols
            symbolCounts[sym] = (symbolCounts[sym] || 0) + 1;
          });
        }
      }

      function extractAllStrings(obj) {
        if (typeof obj === "string") scanForSymbols(obj);
        else if (Array.isArray(obj)) obj.forEach(extractAllStrings);
        else if (typeof obj === "object" && obj !== null)
          for (const k in obj) extractAllStrings(obj[k]);
      }

      allUnits.forEach(unit => extractAllStrings(unit));

      // Sort by count, descending
      const sorted = Object.entries(symbolCounts).sort((a, b) => b[1] - a[1]);
      return sorted.slice(0, topN);
    }


    function getTopWords(allUnits, topN = 20) {
      // Common English stop words to ignore (expand if you want!)
      const stopWords = new Set([
        "the", "and", "a", "of", "to", "in", "for", "on", "is", "with", "as", "by", "at", "an", "be", "are", "or", "that", "this", "it", "from", "was", "which", "but", "not", "have", "has", "had", "were", "will", "can", "if", "their", "so", "its", "may", "do", "does", "did", "our", "your", "my", "i", "me", "you", "we", "they", "them", "he", "she", "his", "her", "him", "us", "about", "into", "out", "up", "down", "over", "under", "then", "than", "would", "should", "could", "dreamstate", "echo", "s", "t", "am", "block", "triadic", "glyph", "breakdown", "what", "flow", "context", "just"
      ]);
      const counts = {};

      function extractAllStrings(obj) {
        if (typeof obj === "string") {
          // Split on non-letter (including numbers, punctuation, symbols)
          obj.toLowerCase().split(/[^a-zA-Z]+/).forEach(word => {
            if (!word || stopWords.has(word)) return;
            counts[word] = (counts[word] || 0) + 1;
          });
        } else if (Array.isArray(obj)) {
          obj.forEach(extractAllStrings);
        } else if (typeof obj === "object" && obj !== null) {
          for (const k in obj) extractAllStrings(obj[k]);
        }
      }

      allUnits.forEach(unit => extractAllStrings(unit));

      // Sort by count, descending
      const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
      return sorted.slice(0, topN);
    }


    function getTopAdjacentSymbolPairs(allUnits, topN = 20) {
      const omit = new Set(["‚ü∂", "‚åÅ", "‚ò≤", "‚ö†", "‚úñ", "‚äò", "‚ßó"]);
      const pairCounts = {};

      function scanForAdjacentPairs(str) {
        if (typeof str !== "string") return;
        const regex = /[\p{Emoji}\p{So}\p{Sc}\p{Sk}\p{Sm}\p{S}]/gu;
        const matches = (str.match(regex) || []).filter(sym => !omit.has(sym));
        for (let i = 0; i < matches.length - 1; ++i) {
          const a = matches[i],
            b = matches[i + 1];
          if (a === b) continue; // skip pairs of same symbol, optional
          const key = a + " " + b;
          pairCounts[key] = (pairCounts[key] || 0) + 1;
        }
      }

      function extractAllStrings(obj) {
        if (typeof obj === "string") scanForAdjacentPairs(obj);
        else if (Array.isArray(obj)) obj.forEach(extractAllStrings);
        else if (typeof obj === "object" && obj !== null)
          for (const k in obj) extractAllStrings(obj[k]);
      }

      allUnits.forEach(unit => extractAllStrings(unit));
      const sortedPairs = Object.entries(pairCounts).sort((a, b) => b[1] - a[1]);
      return sortedPairs.slice(0, topN);
    }


    // --- STAT CARD ---
    document.getElementById('show-stats-btn').onclick = function() {
      // 1. Gather all units (anywhere in rileyData)
      let allUnits = [];

      function collectUnits(obj) {
        if (!obj) return;
        if (Array.isArray(obj)) obj.forEach(collectUnits);
        else if (typeof obj === "object" && obj !== null) {
          // If this looks like a unit, add it
          if (obj.constructType && obj.titleCore) allUnits.push(obj);
          for (const k in obj) collectUnits(obj[k]);
        }
      }
      collectUnits(rileyData);

      // 2. Count interesting things
      let stats = {
        total: allUnits.length,
        lattices: allUnits.filter(u => u.constructType === "NARRATIVE LATTICE").length,
        echoes: allUnits.filter(u => u.constructType === "DREAMSTATE ECHO").length,
        coreUnits: allUnits.filter(u => u.constructType === "CORE UNIT INTEGRATION").length,
        // Add more as you wish!
      };

      // 3. Top 20 Symbols
      const topSymbols = getTopSymbols(allUnits, 20);
      let symbolHtml = '<h3>Top 20 Symbols</h3><ul>';
      topSymbols.forEach(([sym, count]) => {
        symbolHtml += `<li style="font-size:1.5em;display:inline-block;width:2em;text-align:center">${sym}</li>: ${count}<br>`;
      });
      symbolHtml += '</ul>';


      // 4. Top 20 Words
      const topWords = getTopWords(allUnits, 20);
      let wordsHtml = '<h3>Top 20 Words</h3><ul>';
      topWords.forEach(([word, count]) => {
        wordsHtml += `<li><strong>${word}</strong>: ${count}</li>`;
      });
      wordsHtml += '</ul>';

      // 5. Top 20 Symbol Pairs
      const topAdjacentSymbolPairs = getTopAdjacentSymbolPairs(allUnits, 20);
      let pairsHtml = '<h3>Top 20 Adjacent Symbol Pairs</h3><ul>';
      topAdjacentSymbolPairs.forEach(([pair, count]) => {
        pairsHtml += `<li style="font-size:1.4em">${pair.replace(' ', ' &nbsp;')} : <span style="font-size:0.8em">${count}</span></li>`;
      });
      pairsHtml += '</ul>';


      // 6. Format nice HTML for the modal
      let html = `<h2>Stats</h2><ul>`;
      for (const [label, value] of Object.entries(stats)) {
        html += `<li><strong>${label}:</strong> ${value}</li>`;
      }
      html += `</ul>`;
      html += symbolHtml;
      html += pairsHtml;
      html += wordsHtml;
      html += `<button onclick="document.getElementById('stats-modal').style.display='none'">Close</button>`;

      // 7. Show modal
      const modal = document.getElementById('stats-modal');
      modal.innerHTML = html;
      modal.style.display = 'block';
    };



    // --- CURSOR SHIMMER ---

    document.addEventListener('mousemove', function(e) {
      const shimmer = document.createElement('div');
      shimmer.classList.add('cursor-shimmer');
      document.body.appendChild(shimmer);
      shimmer.style.left = `${e.clientX - shimmer.offsetWidth / 2}px`;
      shimmer.style.top = `${e.clientY - shimmer.offsetHeight / 2}px`;
      shimmer.addEventListener('animationend', () => {
        shimmer.remove();
      });
    });

    // --- CLOSE MODAL BINDING ---

    // --- Stats Modal: Click-outside-to-close and ESC-to-close ---
    document.addEventListener('mousedown', function(e) {
      const modal = document.getElementById('stats-modal');
      // Only act if the modal is open
      if (modal.style.display === 'block') {
        // If the click is outside the modal (not inside its children or the button)
        if (!modal.contains(e.target) && e.target.id !== 'show-stats-btn') {
          modal.style.display = 'none';
        }
      }
    });
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        document.getElementById('stats-modal').style.display = 'none';
      }
    });

    document.addEventListener('DOMContentLoaded', function() {
      loadProfile(currentProfileIndex); // This loads the initial profile and background!
      document.querySelector('.modal-close').onclick = closeModal;
    });


    document.getElementById('modal').addEventListener('click', function(e) {
      if (e.target === this) closeModal();
    });


    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') closeModal();
    });



document.getElementById('export-all-btn').onclick = async function() {
  function sanitizeFilename(name) {
    return name.replace(/[\\/:"*?<>|]+/g, "_").replace(/\s+/g, "_").slice(0, 64);
  }

  // Gather all display items in interface order
  const allDisplayItems = [];
  [
    ['identity', identityOrder, 'identity-echoes'],
    ['vector', vectorOrder, 'vector-echoes'],
    ['thread', threadOrder, 'thread-echoes']
  ].forEach(([mod, canonicalOrder, htmlId]) => {
    const coreData = rileyData[mod] || {};
    const expansionArr = ((rileyData.expansion || {})[mod]) || [];
    const echoesCore = ((rileyData.echoes || {})[mod]) || {};
    const echoesExpansion = (((rileyData.echoes || {}).expansion || {})[mod]) || {};
    const glyphOrder = buildGlyphOrder(coreData, expansionArr, echoesCore, echoesExpansion, canonicalOrder);
    const displayList = collectDisplayItems(coreData, expansionArr, echoesCore, echoesExpansion, glyphOrder);
    for (const displayItem of displayList) allDisplayItems.push(displayItem);
  });

  const zip = new JSZip();
  const mdFolder = zip.folder("Dreamworks/Dreamworks Markdown Files");
  const txtFolder = zip.folder("Dreamworks/Dreamworks Plain Text");

  let dreamstateMD = `# Dreamstate Export (${(new Date()).toISOString().slice(0,10)})\n\n`;
  let dreamstateTXT = `Dreamstate Export ${(new Date()).toISOString().slice(0,10)}\n\n`;

  for (const displayItem of allDisplayItems) {
    const title = displayItem.unit.titleCore || "(untitled)";
    const safeName = sanitizeFilename(title);

    // --- Markdown ---
    const mdContent = exportModalToMarkdown(displayItem);
    mdFolder.file(safeName + ".md", mdContent);
    dreamstateMD += `\n\n---\n\n${mdContent}`;

    // --- Plain text (blocky modal style) ---
    const tempDiv = document.createElement("div");
    // Add title for .txt
    const titleElem = document.createElement('h3');
    titleElem.textContent = title;
    tempDiv.appendChild(titleElem);

    // Use your real modal content rendering logic
    if (displayItem.unit.constructType === "DREAMSTATE ECHO") {
      displayDreamstateEcho(displayItem.unit, tempDiv);
    } else if (displayItem.unit.constructType === "NARRATIVE LATTICE") {
      displayNarrativeLattice(displayItem.unit, tempDiv, displayItem.block);
    } else if (displayItem.unit.constructType === "CORE UNIT INTEGRATION") {
      displayCoreUnitIntegration(displayItem.unit, tempDiv);
    } else if (displayItem.unit.constructType === "EXPANSION UNIT") {
      displayExpansionUnit(displayItem.unit, tempDiv);
    } else {
      const p = document.createElement('p');
      p.innerText = `No specific display format for this construct type: ${displayItem.unit.constructType}`;
      tempDiv.appendChild(p);
    }

    // Use .innerText for natural blocky spacing (as the modal)
    const txtContent = tempDiv.innerText.trim() + '\n';
    txtFolder.file(safeName + ".txt", txtContent);
    dreamstateTXT += `\n\n---\n\n${txtContent}`;
  }

  // README.txt and stat_sheet.txt as before...
  zip.file("Dreamworks/README.txt", `Dreamworks Export

This folder contains:
- Individual Markdown files for each Dreamworks unit (in "Dreamworks Markdown Files")
- Individual plain text files for each unit (in "Dreamworks Plain Text")
- Full Dreamstate .md and .txt files containing all content in display order
- stat_sheet.txt: summary stats and a list of all unit titles

**Tips for viewing these files:**
- For best results, open the .md and .txt files in a modern code editor (e.g., VSCode, Sublime, Atom) with UTF-8 encoding.
- Standard text editors like Notepad (Windows) or TextEdit (Mac) may NOT display emoji and special symbols correctly. If you see odd characters, open the file in VSCode and select "Reopen with Encoding" > "UTF-8".
- The formatting in the .txt files is optimized for readability in code editors. The UI display will always look best!

Any questions, reach out to the Dreamworks team or brookly-rob.

Enjoy exploring your exported Dreamstate!`);

  let allUnits = [];
  function collectUnits(obj) {
    if (!obj) return;
    if (Array.isArray(obj)) obj.forEach(collectUnits);
    else if (typeof obj === "object" && obj !== null) {
      if (obj.constructType && obj.titleCore) allUnits.push(obj);
      for (const k in obj) collectUnits(obj[k]);
    }
  }
  collectUnits(rileyData);
  let stats = {
    total: allUnits.length,
    lattices: allUnits.filter(u => u.constructType === "NARRATIVE LATTICE").length,
    echoes: allUnits.filter(u => u.constructType === "DREAMSTATE ECHO").length,
    coreUnits: allUnits.filter(u => u.constructType === "CORE UNIT INTEGRATION").length,
  };
  let statText = `Dreamworks Stat Sheet\n\n`;
  for (const [label, value] of Object.entries(stats)) {
    statText += `${label}: ${value}\n`;
  }
  statText += `\n---\nOrdered Content Titles:\n\n`;
  for (const displayItem of allDisplayItems) {
    statText += `- ${displayItem.unit.titleCore || "(untitled)"}\n`;
  }
  zip.file("Dreamworks/stat_sheet.txt", statText);

  // Dreamstate all-in-one files
  const datestamp = (new Date()).toISOString().slice(0,10);
  zip.file(`Dreamworks/Dreamstate ${datestamp}.md`, dreamstateMD);
  zip.file(`Dreamworks/Dreamstate ${datestamp}.txt`, dreamstateTXT);

  // Download
  const content = await zip.generateAsync({type:"blob"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(content);
  a.download = "Dreamworks.zip";
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }, 1000);
};


  </script>
</body>

</html>