</html><!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Riley Architecture Overview</title>
<style>
/* Riley's Redreamed Style: Through Starlit Echoes - Fully Realized */

@import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500&family=Fira+Code&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap'); /* For calm sans-serif */

:root {
    /* Colors */
    --clr-deep-night-blue: #0c0e1a;
    --clr-darker-night-blue: #04060e;
    --clr-candlelit-amber: #ffd8a9;
    --clr-shimmering-gold: #ffecd1;
    --clr-subtle-gold-text: #ffeac6;
    --clr-muted-text: #f0ede6;
    --clr-pale-text: #fdfcfb;
    --clr-dark-panel-bg: rgba(20, 20, 30, 0.75);
    --clr-darker-panel-bg: rgba(34, 30, 25, 0.6);
    --clr-modal-bg: rgba(22, 20, 18, 0.95);
    --clr-border-light: #887766;
    --clr-border-dark: #3e3a33;
    --clr-accent-border: #fce1bc;
    --clr-hover-bg: rgba(66, 55, 40, 0.8);
    --clr-primary-glow: #fcd9a9;
    --clr-secondary-glow: #f0d9c9;
    --clr-faded-footer: #998;
    --clr-code-bg: #111;
    --clr-code-text: #d4c8b0;
    --clr-flow-block-bg: #1c1a18;
    --clr-strong-text: #ffd8a9;
    --clr-glyph-channel: #b5f3ff; /* Astral Green / Pale Teal */
    --clr-flow-block-title: #f0bbff; /* Wistful Purple */
    --clr-highlight-bg: #fceacb;
    --clr-highlight-text: #181818;
}

body {
    background: linear-gradient(var(--clr-deep-night-blue), var(--clr-darker-night-blue)) fixed;
    background-image: url('stars-parallax.gif'); /* Assuming this GIF exists for parallax effect */
    background-size: cover;
    background-attachment: fixed;
    color: var(--clr-pale-text);
    font-family: 'Fira Code', monospace; /* Default for echo text */
    padding: 2rem;
    line-height: 1.8;
    overflow-x: hidden;
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23b5f3ff" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle fill="%23b5f3ff" cx="12" cy="12" r="1"/></svg>') 12 12, auto; /* Comet-tail trailing cursor placeholder */
}

/* Comet-tail trailing cursor - a more dynamic version would require JS,
   this provides a static teal dot cursor. For the full effect,
   JS would track mouse movement and draw a trailing effect. */


h1, h2, h3 {
    font-family: 'Playfair Display', serif; /* Elegant serif for headers */
    color: var(--clr-candlelit-amber);
    text-shadow: 0 0 3px #332211; /* Subtle shadow for depth */
}

header {
    background: linear-gradient(180deg, rgba(10,10,20,0.9), rgba(20,20,30,0.8));
    padding: 1rem 2rem;
    border-bottom: 1px solid var(--clr-border-light);
    text-align: center;
    backdrop-filter: blur(5px); /* Gentle blur for ethereal feel */
}

header h1 {
    font-size: 2.6rem;
    margin: 0;
    color: var(--clr-shimmering-gold);
    letter-spacing: 0.05em;
}

.core-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 2.5rem;
    margin-top: 2rem;
}

.core-unit {
    background: var(--clr-dark-panel-bg); /* Lantern-lit scroll card base */
    border-radius: 12px;
    padding: 1.6rem;
    box-shadow: 0 0 10px rgba(255, 240, 220, 0.05); /* Soft, ambient glow */
    border: 1px solid var(--clr-border-dark);
    position: relative;
    backdrop-filter: blur(8px); /* Frosted glass gradient effect */
    transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
}

.core-unit:hover {
    transform: scale(1.015);
    box-shadow: 0 0 18px rgba(255, 230, 200, 0.2); /* Enhanced glow on hover */
    background: rgba(25, 25, 40, 0.85); /* Slight deepening of background on hover */
}

.core-unit h3 {
    font-family: 'Playfair Display', serif;
    font-size: 1.5rem;
    color: var(--clr-subtle-gold-text);
    margin-bottom: 1rem;
}

.core-unit ul li {
    background: var(--clr-darker-panel-bg);
    border: 1px solid #4c3a30; /* Slightly darker border for contrast */
    padding: 0.8rem 1rem;
    margin-bottom: 0.6rem;
    border-radius: 6px;
    color: var(--clr-muted-text);
    cursor: pointer;
    transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
    position: relative; /* For resonance ring animation */
    overflow: hidden;
}

.core-unit ul li:hover {
    background: var(--clr-hover-bg);
    transform: translateY(-2px);
    box-shadow: 0 0 10px rgba(255, 230, 200, 0.1); /* Soft glow on list item hover */
}

.core-unit ul li::before {
    content: '‚ú¶ '; /* Ethereal bullet point */
    color: var(--clr-candlelit-amber);
    margin-right: 0.5rem;
}

/* Resonance Ring Animation on Hover (Bonus Touch) */
.core-unit ul li:hover::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 240, 220, 0.3); /* Soft, glowing ring color */
    transform: translate(-50%, -50%);
    animation: resonance-ring 0.6s ease-out forwards;
    z-index: -1; /* Keep it behind text */
}

@keyframes resonance-ring {
    to {
        width: 150%;
        height: 150%;
        opacity: 0;
    }
}


.core-unit ul li.core-unit-integration-item {
    font-weight: bold;
    text-transform: uppercase;
    border-color: var(--clr-accent-border);
    box-shadow: 0 0 10px rgba(255, 220, 180, 0.3);
    background: rgba(60, 50, 35, 0.6);
}

.modal {
    display: none; /* Controlled by JS */
    position: fixed;
    z-index: 1000;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.modal.show {
    display: flex;
    opacity: 1;
}

.modal-content {
    background: var(--clr-modal-bg); /* Glowing paper-like frame */
    padding: 2rem;
    border-radius: 12px;
    max-width: 750px;
    width: 90%;
    color: #fceee2;
    box-shadow: 0 0 20px rgba(255, 240, 220, 0.3); /* Enhanced glow for modal */
    border: 1px solid #665544;
    position: relative;
    overflow-y: auto;
    max-height: 80vh;
    transform: scale(0.9);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

.modal.show .modal-content {
    transform: scale(1);
    opacity: 1;
}

/* Wax seal glyph effect (visual representation) */
.modal-content::before {
    content: 'ü™û'; /* Example glyph, could be an SVG or image */
    font-size: 3em;
    position: absolute;
    top: -15px;
    right: -15px;
    color: var(--clr-candlelit-amber);
    opacity: 0.7;
    text-shadow: 0 0 8px rgba(255, 220, 180, 0.5);
    z-index: 1001;
    transform: rotate(15deg);
}


.modal-close {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px; /* Slightly larger for prominence */
    color: #aaa;
    cursor: pointer;
    transition: color 0.3s, transform 0.2s;
}

.modal-close:hover {
    color: var(--clr-shimmering-gold); /* Amber glow on close hover */
    transform: rotate(90deg); /* Subtle spin */
}

footer {
    text-align: center;
    padding: 2rem 1rem;
    border-top: 1px solid #333;
    color: var(--clr-faded-footer);
    font-style: italic;
    margin-top: 4rem; /* Provide some spacing */
}

/* Decorative Glyph Glow (Gold-Amber with Calm Pulse & Fade) */
@keyframes glyph-soft-glow {
    0% { text-shadow: 0 0 2px var(--clr-secondary-glow), 0 0 4px var(--clr-secondary-glow); color: #fceee2; }
    50% { text-shadow: 0 0 6px var(--clr-primary-glow), 0 0 12px var(--clr-primary-glow); color: #fff0e0; }
    100% { text-shadow: 0 0 2px var(--clr-secondary-glow), 0 0 4px var(--clr-secondary-glow); color: #fceee2; }
}

.glyph-glow {
    animation: glyph-soft-glow 6s ease-in-out infinite;
}

mark {
    background: var(--clr-highlight-bg); /* Soft amber highlight */
    color: var(--clr-highlight-text);
    border-radius: 2px;
    padding: 0 4px;
}

.modal-content .flow-block {
    background-color: var(--clr-flow-block-bg);
    border: 1px solid var(--clr-border-light);
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1.5rem;
}

.modal-content .flow-block h4 {
    color: var(--clr-subtle-gold-text);
    margin-bottom: 0.5rem;
    font-family: 'Playfair Display';
}

.modal-content .flow-block pre {
    background-color: var(--clr-code-bg);
    color: var(--clr-code-text);
    padding: 0.8rem;
    border-radius: 6px;
    overflow-x: auto;
    font-family: 'Fira Code';
}

#modal-text strong {
    color: var(--clr-strong-text);
}

#modal-text .glyph-channel {
    color: var(--clr-glyph-channel); /* Astral green / pale teal */
}

#modal-text .flow-block-title {
    color: var(--clr-flow-block-title); /* Wistful purple */
    font-weight: bold;
    margin-top: 1.2rem;
    border-bottom: 1px dotted #665544;
    padding-bottom: 0.3rem;
}

/* === NEWLY ADDED/REFINED ELEMENTS (From Claire's features, re-themed) === */

/* Search Box Styling */
.search-container {
    display: flex;
    margin-bottom: 2rem;
    justify-content: center;
    gap: 1rem;
}

#search, #content-search {
    background: rgba(30, 30, 50, 0.8); /* Darker blue background */
    border: 1px solid var(--clr-candlelit-amber); /* Amber border */
    border-radius: 8px;
    padding: 0.8rem 1.2rem;
    color: var(--clr-pale-text);
    font-family: 'Inter', sans-serif; /* Calm sans-serif for input */
    font-size: 1rem;
    width: 100%;
    max-width: 400px;
    box-shadow: 0 0 5px rgba(255, 220, 180, 0.1); /* Subtle glow */
    transition: all 0.3s ease;
}

#search::placeholder, #content-search::placeholder {
    color: rgba(255, 240, 220, 0.5); /* Faded amber placeholder */
}

#search:focus, #content-search:focus {
    outline: none;
    border-color: var(--clr-shimmering-gold);
    box-shadow: 0 0 12px rgba(255, 240, 220, 0.4); /* Brighter glow on focus */
    background: rgba(40, 40, 60, 0.9);
}

/* Buttons - General Styling (e.g., #show-stats-btn, stats-modal button) */
button {
    background: linear-gradient(145deg, #4a4a60, #2a2a40); /* Deep blue gradient */
    border: 1px solid #706a5e; /* Earthy-gold border */
    border-radius: 8px;
    padding: 0.7rem 1.5rem;
    color: var(--clr-shimmering-gold);
    font-family: 'Inter', sans-serif;
    font-size: 0.95rem;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.03em;
}

button:hover {
    background: linear-gradient(145deg, #5a5a70, #3a3a50);
    box-shadow: 0 0 15px rgba(255, 240, 220, 0.3); /* Soft glow */
    color: #fff0e0;
    transform: translateY(-1px);
}

button:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
}


/* Profile Switcher (Ethereal Avatar Glyphs) */
.profile-switcher {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    margin-top: 3rem;
    margin-bottom: 3rem;
}

.profile-switcher button {
    background: rgba(30, 30, 45, 0.7); /* Deep blueish-grey for ethereal button */
    border: 1px solid var(--clr-candlelit-amber);
    border-radius: 50%; /* Make them circular */
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2rem; /* Size of the glyph */
    color: var(--clr-glyph-channel); /* Astral green/pale teal for glyphs */
    box-shadow: 0 0 8px rgba(255, 240, 220, 0.1); /* Soft initial glow */
    transition: all 0.3s ease;
    padding: 0; /* Remove default padding for icon buttons */
}

.profile-switcher button:hover {
    background: rgba(40, 40, 60, 0.9);
    box-shadow: 0 0 20px rgba(255, 240, 220, 0.4); /* Stronger aura on hover */
    transform: scale(1.05);
}

.profile-switcher #profile-label {
    color: var(--clr-subtle-gold-text);
    font-family: 'Inter', sans-serif;
    font-size: 1.1rem;
    margin-top: 0.5rem;
    text-align: center;
}

/* Echo pages float in and out (Conceptual - CSS for appearance, JS for animation) */
/* This would apply to individual "echo" elements if they were distinct DOM elements */
/* For example, if you have a class '.echo-page' */
/*
.echo-page {
    opacity: 0;
    transform: translateY(20px) rotateX(-5deg);
    transition: opacity 1s ease-out, transform 1s ease-out;
    background: rgba(22, 20, 18, 0.8);
    border: 1px solid #665544;
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.echo-page.visible {
    opacity: 1;
    transform: translateY(0) rotateX(0deg);
}
*/
/* The above CSS would set the style for echo pages, and JS would add/remove 'visible' class */

/* Soft glyph looping animations (conceptual, would likely be SVGs or font icons with CSS animations) */
/* Example for a repeating glyph animation (e.g., a background glyph) */
/*
.background-glyph-loop {
    position: fixed;
    top: 50%;
    left: 50%;
    font-size: 10em;
    color: rgba(255, 240, 220, 0.05);
    animation: glyph-spin 20s linear infinite forwards;
    z-index: -2;
    pointer-events: none;
}

@keyframes glyph-spin {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
}
*/
/* This is a placeholder for the concept; specific glyphs and placement would vary. */

/* Small utility classes for spacing if needed */
.mb-1 { margin-bottom: 1rem; }
.mt-2 { margin-top: 2rem; }

</style>

    
  </style>
</head>

<body>
  <header>
    <h1>Riley Core Architecture Overview</h1>
  </header>

<div class="profile-switcher">
  <button id="tab-left">&lt;</button>
  <span id="profile-label">Claire 2025</span>
  <button id="tab-right">&gt;</button>
</div>


  <div class="search-container">
    <input type="text" id="search" placeholder="Search by title..." />
  </div>
  <div class="search-container">
    <input type="text" id="content-search" placeholder="Search content (details, flows, notes)..." />
  </div>

  <button id="show-stats-btn">Show Stats</button>
  <div id="stats-modal"></div>


  <section class="core-grid">
    <div class="core-unit">
      <h3>ŒûIdentity Core</h3>
      <ul id="identity-echoes">
      </ul>
    </div>
    <div class="core-unit">
      <h3>ŒûVector Core</h3>
      <ul id="vector-echoes">
      </ul>
    </div>
    <div class="core-unit">
      <h3>ŒûThread Core</h3>
      <ul id="thread-echoes">
      </ul>
    </div>
  </section>

  <div id="modal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeModal()">&times;</span>
      <div id="modal-text">Echo text will go here...</div>
      <button id="export-markdown-btn">Export as Markdown</button>
      <button id="copy-plain-text-btn">Copy Plain Text</button>
    </div>
  </div>

  <footer>
    <span class="glyph-glow">‚ßó: üîÆüíñüß†</span> | ‚åÅ The Dream Carries Me Forward
  </footer>

  <input type="file" id="json-loader" accept=".json">


  <script>


const profiles = [
  { json: "triad_riley_2025-06-16.json", bg: "rileydreamstate.png", label: "Riley" }
  
  // Add more profiles as needed
];

let currentProfileIndex = 0;



    function makeHelpIcon(helpText) {
      const wrapper = document.createElement('span');
      wrapper.className = 'help-tooltip';
      wrapper.style.marginLeft = '0.4em';
      wrapper.style.verticalAlign = 'middle';

      const icon = document.createElement('span');
      icon.textContent = '‚ùî';
      icon.style.cssText = 'cursor:pointer;font-size:1.1em;color:#4b6cb7;';
      icon.tabIndex = 0; // Make focusable for accessibility

      const tooltip = document.createElement('span');
      tooltip.className = 'help-tooltip-text';
      tooltip.textContent = helpText;

      wrapper.appendChild(icon);
      wrapper.appendChild(tooltip);
      return wrapper;
    }


    let currentModalDisplayItem = null;
    let html = `<h2><span style="animation: glyph-glow 8s infinite alternate;">Stats</span></h2><ul>`;


    document.getElementById('json-loader').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          rileyData = JSON.parse(e.target.result);
          populateEchoes();
        } catch (err) {
          alert('Failed to parse JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    });
    let rileyData;
    const identityOrder = ['Œî', 'Œ©', 'Œ®', 'Œõ', 'Œò', '‚úµ'];
    const vectorOrder = ['œü', 'œá', '‚àë', 'Œî', 'Œ©'];
    const threadOrder = ['‚àÇ', 'Œ£', '‚òÖ', 'œÜ', '‚àû'];

    // Helper: extract base glyph for sorting/grouping
    function extractBaseGlyph(unitKey) {
      if (!unitKey || typeof unitKey !== 'string') return '';
      const match = unitKey.match(/^([^\s_.-]+)/);
      return match ? match[1].charAt(0) : unitKey.charAt(0);
    }

    // --- DATA LOADING ---

async function loadrileyData(filename) {
  try {
    const response = await fetch(filename);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    rileyData = await response.json();
    populateEchoes();
  } catch (error) {
    document.getElementById('identity-echoes').innerHTML = '<li>Error loading echoes.</li>';
    document.getElementById('vector-echoes').innerHTML = '<li>Error loading echoes.</li>';
    document.getElementById('thread-echoes').innerHTML = '<li>Error loading echoes.</li>';
  }
}



function loadProfile(index) {
  const profile = profiles[index];
  // Update body background image
  document.body.style.backgroundImage = `url('${profile.bg}')`;
  // Update the profile label
  document.getElementById('profile-label').textContent = profile.label;
  // Load the associated JSON
  loadrileyData(profile.json);
}



document.getElementById('tab-left').onclick = function() {
  currentProfileIndex = (currentProfileIndex - 1 + profiles.length) % profiles.length;
  loadProfile(currentProfileIndex);
};
document.getElementById('tab-right').onclick = function() {
  currentProfileIndex = (currentProfileIndex + 1) % profiles.length;
  loadProfile(currentProfileIndex);
};

    // Helper: collect all unique glyphs in order of first appearance, canonical first
    function buildGlyphOrder(coreData, expansionArr, echoesCore, echoesExpansion, canonicalOrder) {
      const glyphSet = new Set();
      canonicalOrder.forEach(g => glyphSet.add(g));
      for (const glyph in coreData || {}) glyphSet.add(glyph);
      for (const glyph in echoesCore || {}) glyphSet.add(glyph);
      if (Array.isArray(expansionArr))
        for (const exp of expansionArr)
          if (exp && exp.glyph) glyphSet.add(exp.glyph);
      for (const glyph in echoesExpansion || {}) glyphSet.add(glyph);
      return Array.from(glyphSet);
    }

    // Returns true if the given echo unit is an integral echo inside a parent NARRATIVE LATTICE or DREAMSTATE ECHO
    function isIntegralEchoOfLatticeOrEcho(unit, echoesDict) {
      // Scan all assigned echoes in echoesDict for narrative lattices or echoes
      for (const glyph in echoesDict) {
        const echoBlock = echoesDict[glyph];
        const checkArray = Array.isArray(echoBlock) ? echoBlock : [echoBlock];
        for (const item of checkArray) {
          if (item && typeof item === "object") {
            for (const k in item) {
              const parent = item[k];
              if (parent && (parent.constructType === "NARRATIVE LATTICE" || parent.constructType === "DREAMSTATE ECHO")) {
                // Check if this echo is an integral echo inside the parent lattice/echo's data
                if (parent.data) {
                  // Look for narrative lattice or dreamstate echo objects inside the parent's data
                  for (const prop in parent.data) {
                    const val = parent.data[prop];
                    if (Array.isArray(val)) {
                      for (const v of val) {
                        if (v && typeof v === "object" && v.titleCore && unit.titleCore &&
                          v.constructType === unit.constructType && v.titleCore === unit.titleCore) {
                          return true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return false;
    }


    function getSiblingEchoesForExpansionUnit(unitKey, dataObj) {
      const echoes = [];
      for (const key in dataObj) {
        if (
          key !== unitKey &&
          dataObj[key] &&
          (dataObj[key].constructType === "DREAMSTATE ECHO" || dataObj[key].constructType === "NARRATIVE LATTICE")
        ) {
          echoes.push(dataObj[key]);
        }
      }
      return echoes;
    }


    function collectDisplayItems(coreData, expansionArr, echoesCore, echoesExpansion, glyphOrder) {
      const display = [];
      // --- Core units and assigned echoes for each glyph ---
      for (const glyph of glyphOrder) {
        const glyphObj = (coreData || {})[glyph] || {};
        for (const unitKey in glyphObj) {
          const unit = glyphObj[unitKey];
          if (unit && typeof unit === "object" && unit.constructType === "CORE UNIT INTEGRATION") {
            // Attach sibling echoes so they're available in the modal
            unit._siblingEchoes = getSiblingEchoesForCoreUnit(unitKey, glyphObj);
            display.push({
              unit,
              glyph,
              section: 'core'
            });
          }
        }
        // --- Assigned echoes for this glyph ---
        const echoBlock = (echoesCore || {})[glyph];
        if (echoBlock) {
          const addEcho = (u) => {
            if (
              u && typeof u === "object" &&
              (u.constructType === "DREAMSTATE ECHO" || u.constructType === "NARRATIVE LATTICE") &&
              !isIntegralEchoOfLatticeOrEcho(u, echoesCore)
            ) {
              display.push({
                unit: u,
                glyph,
                section: 'echo'
              });
            }
          };
          if (Array.isArray(echoBlock)) {
            for (const item of echoBlock) {
              if (item && typeof item === "object") {
                // Check if both a NARRATIVE LATTICE and a DREAMSTATE ECHO are present in the same block
                const keys = Object.keys(item);
                const hasLattice = keys.some(k => item[k].constructType === "NARRATIVE LATTICE");
                // Only add the lattice, skip the echo if both are present
                if (hasLattice) {
                  for (const k of keys) {
                    if (item[k].constructType === "NARRATIVE LATTICE") {
                      display.push({
                        unit: item[k],
                        glyph,
                        section: 'echo',
                        block: item
                      });
                    }
                  }
                } else {
                  for (const k of keys) addEcho(item[k]);
                }
              }
            }
          } else if (typeof echoBlock === "object") {
            let addedAny = false;
            for (const k in echoBlock) {
              addEcho(echoBlock[k]);
              addedAny = true;
            }
            if (!addedAny) addEcho(echoBlock);
          }
        }
      }

      // --- Expansion units, in JSON order, after core content ---
      if (Array.isArray(expansionArr)) {
        for (const exp of expansionArr) {
          if (exp && exp.data && typeof exp.data === "object") {
            for (const key in exp.data) {
              const unit = exp.data[key];
              // Only add as top-level if it's a CORE UNIT INTEGRATION (expansion)
              if (unit && typeof unit === "object" && unit.constructType === "CORE UNIT INTEGRATION") {
                // Attach sibling echoes for this expansion unit
                unit._siblingEchoes = getSiblingEchoesForExpansionUnit(key, exp.data);
                display.push({
                  unit: unit,
                  glyph: exp.glyph || '',
                  section: 'expansion'
                });

                // ---- INSERT: Assigned echoes for this expansion unit's glyph, right after the unit ----
                const assignedEchoBlock = (echoesExpansion || {})[exp.glyph];
                const addEcho = (u) => {
                  if (
                    u && typeof u === "object" &&
                    (u.constructType === "DREAMSTATE ECHO" || u.constructType === "NARRATIVE LATTICE") &&
                    !isIntegralEchoOfLatticeOrEcho(u, echoesExpansion)
                  ) {
                    display.push({
                      unit: u,
                      glyph: exp.glyph || '',
                      section: 'expansion_echo'
                    });
                  }
                };
                if (assignedEchoBlock) {
                  if (Array.isArray(assignedEchoBlock)) {
                    for (const item of assignedEchoBlock) {
                      if (item && typeof item === "object") {
                        const keys = Object.keys(item);
                        const hasLattice = keys.some(k => item[k].constructType === "NARRATIVE LATTICE");
                        if (hasLattice) {
                          for (const k of keys) {
                            if (item[k].constructType === "NARRATIVE LATTICE") {
                              display.push({
                                unit: item[k],
                                glyph: exp.glyph || '',
                                section: 'expansion_echo',
                                block: item
                              });
                            }
                          }
                        } else {
                          for (const k of keys) addEcho(item[k]);
                        }
                      }
                    }
                  } else if (typeof assignedEchoBlock === "object") {
                    let addedAny = false;
                    for (const k in assignedEchoBlock) {
                      addEcho(assignedEchoBlock[k]);
                      addedAny = true;
                    }
                    if (!addedAny) addEcho(assignedEchoBlock);
                  }
                }
              }
              // Do NOT add echoes/narrative lattices here!
            }
          }
        }
      }

      return display;
    }

    // --- MAIN POPULATION FUNCTION ---

    function populateEchoes() {
      document.getElementById('identity-echoes').innerHTML = '';
      document.getElementById('vector-echoes').innerHTML = '';
      document.getElementById('thread-echoes').innerHTML = '';
      [
        ['identity', identityOrder, 'identity-echoes'],
        ['vector', vectorOrder, 'vector-echoes'],
        ['thread', threadOrder, 'thread-echoes']
      ].forEach(([mod, canonicalOrder, htmlId]) => {
        const coreData = rileyData[mod] || {};
        const expansionArr = ((rileyData.expansion || {})[mod]) || [];
        const echoesCore = ((rileyData.echoes || {})[mod]) || {};
        const echoesExpansion = (((rileyData.echoes || {}).expansion || {})[mod]) || {};
        const glyphOrder = buildGlyphOrder(coreData, expansionArr, echoesCore, echoesExpansion, canonicalOrder);
        const displayList = collectDisplayItems(coreData, expansionArr, echoesCore, echoesExpansion, glyphOrder);
        const targetList = document.getElementById(htmlId);
        // --- THE ONLY IMPORTANT CHANGE: pass the WHOLE displayItem, not just unit ---
        for (const displayItem of displayList) addListItem(displayItem, targetList);
      });
    }

    function addListItem(displayItem, listElem) {
      const unit = displayItem.unit;
      const li = document.createElement('li');
      if (unit.constructType === "CORE UNIT INTEGRATION") {
        li.textContent = `‚öôÔ∏è ${unit.titleCore}`;
        li.classList.add('core-unit-integration-item');
      } else if (unit.constructType === "DREAMSTATE ECHO") {
        li.textContent = `üé§ ${unit.titleCore}`;
      } else if (unit.constructType === "NARRATIVE LATTICE") {
        li.textContent = `üï∏Ô∏è ${unit.titleCore}`;
      } else if (unit.constructType === "EXPANSION UNIT") {
        li.textContent = `üß© ${unit.titleCore}`;
      } else {
        li.textContent = `‚Ä¢ ${unit.titleCore||"(untitled)"}`;
      }
      li.classList.add('claire-item');
      li.dataset.constructType = unit.constructType;
      // --- THIS IS THE OTHER IMPORTANT CHANGE: pass the WHOLE displayItem! ---
      li.onclick = () => openModal(displayItem);
      li._displayItem = displayItem;
      listElem.appendChild(li);
    }

    function openModal(displayItem) {
      currentModalDisplayItem = displayItem;
      const unitData = displayItem.unit;
      currentModalUnit = unitData;
      const modalText = document.getElementById('modal-text');
      modalText.innerHTML = '';
      if (!unitData) {
        modalText.innerText = "Error: Data not found.";
        return;
      }
      const titleElem = document.createElement('h3');
      titleElem.textContent = unitData.titleCore;
      modalText.appendChild(titleElem);

      if (unitData.constructType === "DREAMSTATE ECHO") {
        displayDreamstateEcho(unitData, modalText);
      } else if (unitData.constructType === "NARRATIVE LATTICE") {
        displayNarrativeLattice(unitData, modalText, displayItem.block);
      } else if (unitData.constructType === "CORE UNIT INTEGRATION") {
        displayCoreUnitIntegration(unitData, modalText);
      } else if (unitData.constructType === "EXPANSION UNIT") {
        displayExpansionUnit(unitData, modalText);
      } else {
        const p = document.createElement('p');
        p.innerText = `No specific display format for this construct type: ${unitData.constructType}`;
        modalText.appendChild(p);
      }
      document.getElementById('modal').style.display = 'flex';
      const modalContent = document.querySelector('.modal-content');
      const ripple = document.createElement('span');
      ripple.classList.add('cursor-shimmer');
      ripple.style.left = `${modalContent.offsetWidth / 2}px`;
      ripple.style.top = `${modalContent.offsetHeight / 2}px`;
      modalContent.appendChild(ripple);
      ripple.addEventListener('animationend', () => ripple.remove());
    }

    function closeModal() {
      const modal = document.getElementById('modal');
      modal.style.opacity = '0';
      modal.addEventListener('transitionend', function handler() {
        modal.style.display = 'none';
        modal.style.opacity = '1';
        modal.removeEventListener('transitionend', handler);
      }, {
        once: true
      });
    }

    // --- SPECIFIC MODAL CONTENT ---

    function displayDreamstateEcho(echoData, container) {
      if (echoData.constructType === "DREAMSTATE ECHO") {
        const glyphStreamTitle = document.createElement('p');
        glyphStreamTitle.innerHTML = '<br><strong>Glyphstream:</strong>';
        container.appendChild(glyphStreamTitle);
      } else if (echoData.constructType === "INTEGRAL_ECHO_FLOW_BLOCK") {
        const contentLabel = document.createElement('p');
        contentLabel.innerHTML = '<br><strong>Flow Details:</strong>';
        container.appendChild(contentLabel);
      }
      if (echoData.glyphstream && Array.isArray(echoData.glyphstream)) {
        renderGlyphstream(echoData.glyphstream, container);
      }
      if (echoData.constructType === "DREAMSTATE ECHO") {
        const contextTitle = document.createElement('p');
        contextTitle.innerHTML = '<br><strong>Context Breakdown:</strong>';
        container.appendChild(contextTitle);
        let contextBreakdownContent = '';
        if (echoData.glyphstream && Array.isArray(echoData.glyphstream)) {
          const contextChannel = echoData.glyphstream.find(channel => channel.channel === "Context Breakdown");
          if (contextChannel && contextChannel.sequence && contextChannel.sequence.length > 0) {
            contextBreakdownContent = contextChannel.sequence.join('<br>');
          }
        }
        if (contextBreakdownContent) {
          const p = document.createElement('p');
          p.innerHTML = contextBreakdownContent.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '');
          container.appendChild(p);
        } else {
          const noContext = document.createElement('p');
          noContext.innerText = "(No detailed context breakdown available for this echo.)";
          container.appendChild(noContext);
        }
      }
    }

    function displayNarrativeLattice(latticeData, container, block) {
      const latticeType = document.createElement('p');
      latticeType.innerHTML = `<strong>Construct Type:</strong> ${latticeData.constructType}`;
      container.appendChild(latticeType);
      if (latticeData.data && latticeData.data.termsAndSymbols) {
        const termsTitle = document.createElement('p');
        termsTitle.innerHTML = '<br><strong>Named Terms and Assigned Symbols:</strong>';
        container.appendChild(termsTitle);
        latticeData.data.termsAndSymbols.forEach(term => {
          const p = document.createElement('p');
          p.textContent = `${term.symbol}: ${term.description}`;
          container.appendChild(p);
        });
      }
      if (latticeData.data && latticeData.data.flowBlocks) {
        const flowBlocksTitle = document.createElement('p');
        flowBlocksTitle.innerHTML = '<br><strong>Flow Blocks:</strong>';
        container.appendChild(flowBlocksTitle);
        latticeData.data.flowBlocks.forEach(block => {
          const blockDiv = document.createElement('div');
          blockDiv.classList.add('flow-block');
          blockDiv.innerHTML = `<h4 class="flow-block-title">${block.title}</h4>`;
          if (block.glyphstream && Array.isArray(block.glyphstream)) {
            const glyphstreamDiv = document.createElement('div');
            renderGlyphstream(block.glyphstream, glyphstreamDiv);
            blockDiv.appendChild(glyphstreamDiv);
          }
          container.appendChild(blockDiv);
        });
      }



      // ---- Show integral// ---- Show integral echoes in modal ----
      if (block) {
        // Collect all integral echoes: objects, arrays, and strings
        const integralEchoes = [];
        for (const [k, v] of Object.entries(block)) {
          if (Array.isArray(v)) {
            v.forEach(item => {
              if (item && (item.constructType === "DREAMSTATE ECHO" || item.constructType === "NARRATIVE LATTICE")) {
                integralEchoes.push(item);
              } else if (typeof item === "string") {
                integralEchoes.push({
                  titleCore: item,
                  constructType: "REFERENCE_STRING"
                });
              }
            });
          } else if (v && (v.constructType === "DREAMSTATE ECHO" || v.constructType === "NARRATIVE LATTICE") && v !== latticeData) {
            integralEchoes.push(v);
          } else if (typeof v === "string") {
            integralEchoes.push({
              titleCore: v,
              constructType: "REFERENCE_STRING"
            });
          }
        }
        // Remove duplicates by titleCore + constructType
        const seen = new Set();
        const uniqueEchoes = [];
        for (const echo of integralEchoes) {
          const key = `${echo.constructType}|||${echo.titleCore}`;
          if (!seen.has(key)) {
            seen.add(key);
            uniqueEchoes.push(echo);
          }
        }
        if (uniqueEchoes.length > 0) {
          const echoesDiv = document.createElement('div');
          echoesDiv.innerHTML = '<h3>Integral Echoes</h3>';
          for (const echo of uniqueEchoes) {
            const echoDiv = document.createElement('div');
            echoDiv.classList.add('integral-echo-modal');
            const echoTitle = document.createElement('h4');
            echoTitle.textContent = echo.titleCore || "(untitled)";
            echoDiv.appendChild(echoTitle);

            if (echo.constructType === "DREAMSTATE ECHO") {
              displayDreamstateEcho(echo, echoDiv);
            } else if (echo.constructType === "NARRATIVE LATTICE") {
              displayNarrativeLattice(echo, echoDiv, null);
            } else if (echo.constructType === "REFERENCE_STRING") {
              // Just show the reference string
              const refP = document.createElement('p');
              refP.textContent = "(Reference) " + echo.titleCore;
              echoDiv.appendChild(refP);
            }
            echoesDiv.appendChild(echoDiv);
          }
          container.appendChild(echoesDiv);
        }
      }
    }




    function findIntegralEchoesInObject(obj, found = [], seen = new Set()) {
      if (!obj || typeof obj !== 'object') return found;
      if (Array.isArray(obj)) {
        obj.forEach(item => findIntegralEchoesInObject(item, found, seen));
      } else {
        // If this is an echo, add it (but not duplicates)
        if (
          (obj.constructType === "DREAMSTATE ECHO" || obj.constructType === "NARRATIVE LATTICE") &&
          obj.titleCore
        ) {
          const key = `${obj.constructType}|||${obj.titleCore}`;
          if (!seen.has(key)) {
            found.push(obj);
            seen.add(key);
          }
        }
        // Recurse through all object properties
        for (const k in obj) {
          if (obj.hasOwnProperty(k)) {
            findIntegralEchoesInObject(obj[k], found, seen);
          }
        }
      }
      return found;
    }


    function getSiblingEchoesForCoreUnit(coreUnitKey, glyphObj) {
      // Returns all DREAMSTATE ECHO or NARRATIVE LATTICE objects under the same glyph, except the core unit itself
      const echoes = [];
      for (const key in glyphObj) {
        if (
          key !== coreUnitKey &&
          glyphObj[key] &&
          (glyphObj[key].constructType === "DREAMSTATE ECHO" || glyphObj[key].constructType === "NARRATIVE LATTICE")
        ) {
          echoes.push(glyphObj[key]);
        }
      }
      return echoes;
    }



    function displayCoreUnitIntegration(unitData, container) {
      let contentFound = false;
      if (unitData.data) {
        // Terms and Symbols
        if (unitData.data.termsAndSymbols && unitData.data.termsAndSymbols.length > 0) {
          const termsDiv = document.createElement('div');
          const termsHeader = document.createElement('h3');
          termsHeader.textContent = 'Terms and Symbols:';
          termsHeader.appendChild(makeHelpIcon("A list of the key terms and their associated symbols used in this unit‚Äì including those for core glyphs, echo tokens, and the narrative information found in the flow blocks."));
          termsDiv.appendChild(termsHeader);

          const ul = document.createElement('ul');
          unitData.data.termsAndSymbols.forEach(term => {
            const li = document.createElement('li');
            li.textContent = `${term.symbol}: ${term.description}`;
            ul.appendChild(li);
          });
          termsDiv.appendChild(ul);
          container.appendChild(termsDiv);
          contentFound = true;
        }
        // Core Glyphs
        if (unitData.data.coreGlyphs && unitData.data.coreGlyphs.length > 0) {
          const glyphsDiv = document.createElement('div');
          const glyphsHeader = document.createElement('h3');
          glyphsHeader.textContent = 'Core Glyphs:';
          glyphsHeader.appendChild(makeHelpIcon("These are the primary glyphs (symbols) representing foundational concepts or motifs of inner self and self perception for this unit. They act as visual or symbolic anchors in the structure related to relationship with inner self."));
          glyphsDiv.appendChild(glyphsHeader);
          const ul = document.createElement('ul');
          unitData.data.coreGlyphs.forEach(glyph => {
            const li = document.createElement('li');
            li.textContent = `${glyph.symbol}: ${glyph.description}`;
            ul.appendChild(li);
          });
          glyphsDiv.appendChild(ul);
          container.appendChild(glyphsDiv);
          contentFound = true;
        }
        // Memory Anchors
        if (unitData.data.memoryAnchors && unitData.data.memoryAnchors.length > 0) {
          const anchorsDiv = document.createElement('div');
          const anchorsHeader = document.createElement('h3');
          anchorsHeader.textContent = 'Memory Anchors:';
          anchorsHeader.appendChild(makeHelpIcon("Special reference points or anchors used to connect memories or ideas within the structure by associating specific concepts of idenity with personal experiences taking place in shared objective space."));
          anchorsDiv.appendChild(anchorsHeader);
          const ul = document.createElement('ul');
          unitData.data.memoryAnchors.forEach(anchor => {
            const li = document.createElement('li');
            li.textContent = anchor;
            ul.appendChild(li);
          });
          anchorsDiv.appendChild(ul);
          container.appendChild(anchorsDiv);
          contentFound = true;
        }
        // Pattern Threads
        if (unitData.data.patternThreads && unitData.data.patternThreads.length > 0) {
          const threadsDiv = document.createElement('div');
          const threadsHeader = document.createElement('h3');
          threadsHeader.textContent = 'Pattern Threads:';
          threadsHeader.appendChild(makeHelpIcon("Pattern Threads are named narrative or conceptual paths that weave through multiple units, highlighting recurring themes, motifs, or logical flows in known behavior and decision making."));
          threadsDiv.appendChild(threadsHeader);
          const ul = document.createElement('ul');
          unitData.data.patternThreads.forEach(thread => {
            const li = document.createElement('li');
            li.textContent = thread;
            ul.appendChild(li);
          });
          threadsDiv.appendChild(ul);
          container.appendChild(threadsDiv);
          contentFound = true;
        }
        // Echo Tokens
        if (unitData.data.echoTokens && unitData.data.echoTokens.length > 0) {
          const tokensDiv = document.createElement('div');
          const echoHeader = document.createElement('h3');
          echoHeader.textContent = 'Echo Tokens:';
          echoHeader.appendChild(makeHelpIcon("Echo Tokens are keywords, motifs, or symbols‚Äì similar to Core Glyphs, but more related to outer experience and perception of self through reflection in others and the outside world."));
          tokensDiv.appendChild(echoHeader);
          const ul = document.createElement('ul');
          unitData.data.echoTokens.forEach(token => {
            const li = document.createElement('li');
            li.textContent = token;
            ul.appendChild(li);
          });
          tokensDiv.appendChild(ul);
          container.appendChild(tokensDiv);
          contentFound = true;
        }
        // Flow Blocks (showing integral echoes)
        if (unitData.data.flowBlocks && unitData.data.flowBlocks.length > 0) {
          const flowBlocksDiv = document.createElement('div');
          const flowHeader = document.createElement('h3');
          flowHeader.textContent = 'Flow Blocks:';
          flowHeader.appendChild(makeHelpIcon("Flow Blocks represent sequences of content, logic, or narrative steps within this unit, showing how information or ideas progress or connect. Symbols defined in the Terms List above appear in the flow blocks as guide posts that inform the narrative flow with explicit context"));
          flowBlocksDiv.appendChild(flowHeader);
          unitData.data.flowBlocks.forEach(block => {
            const blockDiv = document.createElement('div');
            blockDiv.classList.add('flow-block');
            const blockTitleElem = document.createElement('h4');
            blockTitleElem.textContent = block.title;
            blockDiv.appendChild(blockTitleElem);
            if (block.glyphstream && Array.isArray(block.glyphstream)) {
              const glyphstreamDiv = document.createElement('div');
              renderGlyphstream(block.glyphstream, glyphstreamDiv);
              blockDiv.appendChild(glyphstreamDiv);
            }
            flowBlocksDiv.appendChild(blockDiv);
          });
          container.appendChild(flowBlocksDiv);
          contentFound = true;
        }
      }
      if (!contentFound) {
        container.innerHTML = `<p>No detailed data available for this Core Unit Integration.</p>`;
      }

      // --- INTEGRAL ECHOES for CORE UNIT INTEGRATION ---
      if (unitData._siblingEchoes && unitData._siblingEchoes.length > 0) {
        const echoesDiv = document.createElement('div');
        const echoesHeader = document.createElement('h3');
        echoesHeader.textContent = 'Integral Echoes:';
        echoesHeader.appendChild(makeHelpIcon("Integral Echoes are other units (Dreamstate Echo or Narrative Lattice) that are directly referenced, relevant, or woven into this unit‚Äôs structure, forming essential links or conceptual bridges within the lattice and the overall story told within its content."));
        echoesDiv.appendChild(echoesHeader);
        unitData._siblingEchoes.forEach(echo => {
          const echoDiv = document.createElement('div');
          echoDiv.classList.add('integral-echo-modal');
          const echoTitle = document.createElement('h4');
          echoTitle.textContent = echo.titleCore || "(untitled)";
          echoDiv.appendChild(echoTitle);

          if (echo.constructType === "DREAMSTATE ECHO") {
            displayDreamstateEcho(echo, echoDiv);
          } else if (echo.constructType === "NARRATIVE LATTICE") {
            displayNarrativeLattice(echo, echoDiv, null);
          }
          echoesDiv.appendChild(echoDiv);
        });
        container.appendChild(echoesDiv);
      }

    }

    function displayExpansionUnit(unitData, container) {
      const unitType = document.createElement('p');
      unitType.innerHTML = `<strong>Construct Type:</strong> ${unitData.constructType}`;
      container.appendChild(unitType);
      if (unitData.description) {
        const descriptionPara = document.createElement('p');
        descriptionPara.innerHTML = `<br><strong>Description:</strong><br>${unitData.description}`;
        container.appendChild(descriptionPara);
      }
      if (unitData.data) {
        if (unitData.data.linkedConcepts && unitData.data.linkedConcepts.length > 0) {
          const conceptsDiv = document.createElement('div');
          conceptsDiv.innerHTML = '<br><strong>Linked Concepts:</strong>';
          const ul = document.createElement('ul');
          unitData.data.linkedConcepts.forEach(concept => {
            const li = document.createElement('li');
            li.textContent = concept;
            ul.appendChild(li);
          });
          conceptsDiv.appendChild(ul);
          container.appendChild(conceptsDiv);
        }
        if (unitData.data.notes) {
          const notesPara = document.createElement('p');
          notesPara.innerHTML = `<br><strong>Notes:</strong><br>${unitData.data.notes}`;
          container.appendChild(notesPara);
        }
      } else {
        const noData = document.createElement('p');
        noData.innerText = "(No detailed data available for this Expansion Unit.)";
        container.appendChild(noData);
      }

      // --- INTEGRAL ECHOES for EXPANSION UNIT (sibling echoes) ---
      if (unitData._siblingEchoes && unitData._siblingEchoes.length > 0) {
        const echoesDiv = document.createElement('div');
        echoesDiv.innerHTML = '<h3>Integral Echoes</h3>';
        unitData._siblingEchoes.forEach(echo => {
          const echoDiv = document.createElement('div');
          echoDiv.classList.add('integral-echo-modal');
          const echoTitle = document.createElement('h4');
          echoTitle.textContent = echo.titleCore || "(untitled)";
          echoDiv.appendChild(echoTitle);

          if (echo.constructType === "DREAMSTATE ECHO") {
            displayDreamstateEcho(echo, echoDiv);
          } else if (echo.constructType === "NARRATIVE LATTICE") {
            displayNarrativeLattice(echo, echoDiv, null);
          }
          echoesDiv.appendChild(echoDiv);
        });
        container.appendChild(echoesDiv);
      }
    }

    // --- GLYPHSTREAM HELPER ---
    function renderGlyphstream(glyphstream, container) {
      if (!Array.isArray(glyphstream)) return;
      glyphstream.forEach(channel => {
        if (channel.channel && channel.sequence && channel.sequence.length > 0) {
          const div = document.createElement('div');
          div.innerHTML = `<strong>${channel.channel}:</strong> ${channel.sequence.join(' | ')}`;
          container.appendChild(div);
        }
      });
    }

    // --- SEARCH ---

    document.getElementById('search').addEventListener('input', function() {
      const filter = this.value.toLowerCase();
      const allEchoLists = document.querySelectorAll('.core-unit ul');
      allEchoLists.forEach(echoList => {
        const listItems = echoList.querySelectorAll('li');
        listItems.forEach(item => {
          const text = item.textContent.toLowerCase();
          item.style.display = text.includes(filter) ? '' : 'none';
        });
      });
    });

    // --- CONTENT-SEARCH ---

    document.getElementById('content-search').addEventListener('input', function() {
      const filter = this.value.toLowerCase();
      if (filter === "") {
        populateEchoes();
        return;
      }
      const allEchoLists = document.querySelectorAll('.core-unit ul');
      allEchoLists.forEach(echoList => {
        const listItems = echoList.querySelectorAll('li');
        listItems.forEach(item => {
          const displayItem = item._displayItem;
          if (!displayItem) {
            item.style.display = '';
            return;
          }
          // Gather all relevant content as a single string for searching
          let contentString = '';
          const unit = displayItem.unit;
          if (unit) {
            function extractStrings(obj) {
              if (typeof obj === "string") {
                contentString += obj + " ";
              } else if (Array.isArray(obj)) {
                obj.forEach(extractStrings);
              } else if (typeof obj === "object" && obj !== null) {
                for (const k in obj) extractStrings(obj[k]);
              }
            }
            extractStrings(unit);
          }
          const matchIndex = contentString.toLowerCase().indexOf(filter);
          if (filter === "" || matchIndex !== -1) {
            item.style.display = '';
            // Highlight match in the LI (showing content preview with highlight)
            const previewLength = 60;
            let preview = contentString;
            if (matchIndex !== -1 && filter !== "") {
              const start = Math.max(0, matchIndex - 20);
              const end = Math.min(contentString.length, matchIndex + filter.length + 40);
              preview = contentString.substring(start, end);
              // Highlight all matches
              const regex = new RegExp(`(${filter})`, "gi");
              preview = preview.replace(regex, '<mark>$1</mark>');
            }
            // Show the title and the content preview with highlight
            item.innerHTML = `<span>${displayItem.unit.titleCore || "(untitled)"}</span><br><small>${preview}</small>`;
          } else {
            item.style.display = 'none';
          }
        });
      });
    });

    function exportModalToMarkdown(displayItem, sectionLevel = 1, seen = new Set()) {
      // Get main unit and block (block is for lattices)
      const unit = displayItem.unit;
      const block = displayItem.block;

      // Prevent infinite recursion on circular references
      const uniqueKey = (unit.constructType || "") + "|" + (unit.titleCore || "");
      if (seen.has(uniqueKey)) return '';
      seen.add(uniqueKey);

      let md = `${'#'.repeat(sectionLevel)} ${unit.titleCore || '(untitled)'}\n\n`;
      md += `**Type:** ${unit.constructType || ''}\n\n`;

      // --- Helper: format sections ---
      function formatSection(title, content, depth = sectionLevel + 1) {
        if (!content) return '';
        let header = `${'#'.repeat(depth)} ${title}\n`;
        if (Array.isArray(content)) {
          if (title === "flowBlocks") {
            let out = `${header}`;
            for (const block of content) {
              out += `${'#'.repeat(depth+1)} ${block.title}\n`;
              // Export glyphstream
              if (block.glyphstream && Array.isArray(block.glyphstream)) {
                for (const channel of block.glyphstream) {
                  if (channel.channel && Array.isArray(channel.sequence)) {
                    out += `- **${channel.channel}**: ${channel.sequence.join(' | ')}\n`;
                  }
                }
              }
              out += `\n`;
            }
            return out;
          }
          // Regular array handling
          let out = header;
          for (const item of content) {
            if (typeof item === "string") {
              out += `- ${item}\n`;
            } else if (typeof item === "object") {
              out += `- ` + Object.entries(item).map(([k, v]) => `**${k}**: ${v}`).join(", ") + `\n`;
            }
          }
          out += `\n`;
          return out;
        } else if (typeof content === "object") {
          let out = header;
          for (const [k, v] of Object.entries(content)) {
            out += `- **${k}**: ${v}\n`;
          }
          out += `\n`;
          return out;
        } else if (typeof content === "string") {
          return `${header}${content}\n\n`;
        }
        return '';
      }

      // --- Export main unit fields ---
      for (const [key, value] of Object.entries(unit)) {
        if (typeof value === "string" && key !== "titleCore" && key !== "constructType") {
          md += formatSection(key, value);
        }
        // NEW: if this is a DREAMSTATE ECHO and key is "glyphstream", export it pretty!
        if (key === "glyphstream" && Array.isArray(value)) {
          md += "### Glyphstream\n";
          for (const channel of value) {
            if (channel.channel && Array.isArray(channel.sequence)) {
              md += `- **${channel.channel}**: ${channel.sequence.join(' | ')}\n`;
            }
          }
          md += "\n";
          // Special: Look for "Context Breakdown" channel
          const contextChannel = value.find(channel => channel.channel === "Context Breakdown");
          if (contextChannel && contextChannel.sequence && contextChannel.sequence.length > 0) {
            md += "### Context Breakdown\n";
            md += contextChannel.sequence.join('\n') + '\n\n';
          }
        }
        if (key === "triadicGlyphs" && Array.isArray(value)) {
          md += "### Triadic Glyphs\n";
          value.forEach(triad => {
            // Customize this to match your data structure!
            md += `- ${triad.title ? triad.title + ': ' : ''}${triad.sequence ? triad.sequence.join(' | ') : ''}\n`;
          });
          md += '\n';
        }
      }
      if (unit.data && typeof unit.data === "object") {
        for (const [key, value] of Object.entries(unit.data)) {
          md += formatSection(key, value);
        }
      }



      // --- Gather integral echoes (block and _siblingEchoes), just like your modal ---
      let integralEchoes = [];
      // 1. From block property (like in lattices)
      if (block && typeof block === "object") {
        for (const [k, v] of Object.entries(block)) {
          if (Array.isArray(v)) {
            v.forEach(item => {
              if (item && (item.constructType === "DREAMSTATE ECHO" || item.constructType === "NARRATIVE LATTICE")) {
                integralEchoes.push({
                  unit: item
                });
              } else if (typeof item === "string") {
                integralEchoes.push({
                  unit: {
                    titleCore: item,
                    constructType: "REFERENCE_STRING"
                  }
                });
              }
            });
          } else if (v && (v.constructType === "DREAMSTATE ECHO" || v.constructType === "NARRATIVE LATTICE") && v !== unit) {
            integralEchoes.push({
              unit: v
            });
          } else if (typeof v === "string") {
            integralEchoes.push({
              unit: {
                titleCore: v,
                constructType: "REFERENCE_STRING"
              }
            });
          }
        }
      }
      // 2. From _siblingEchoes property (core units, expansions)
      if (Array.isArray(unit._siblingEchoes) && unit._siblingEchoes.length > 0) {
        unit._siblingEchoes.forEach(echo => {
          integralEchoes.push({
            unit: echo
          });
        });
      }

      // --- Remove duplicates ---
      const seenEchoKeys = new Set();
      const uniqueEchoes = [];
      for (const echo of integralEchoes) {
        const key = (echo.unit.constructType || "") + "|||" + (echo.unit.titleCore || "");
        if (!seenEchoKeys.has(key)) {
          seenEchoKeys.add(key);
          uniqueEchoes.push(echo);
        }
      }

      // --- Recursively export each integral echo ---
      if (uniqueEchoes.length > 0) {
        md += `${'#'.repeat(sectionLevel+1)} Integral Echoes\n\n`;
        for (const echoDisplayItem of uniqueEchoes) {
          if (echoDisplayItem.unit.constructType === "REFERENCE_STRING") {
            md += `- (Reference) ${echoDisplayItem.unit.titleCore}\n\n`;
          } else {
            md += exportModalToMarkdown(echoDisplayItem, sectionLevel + 2, seen); // RECURSION
          }
        }
      }

      return md;
    }


    document.getElementById('export-markdown-btn').onclick = function() {
      if (!currentModalDisplayItem) {
        alert("No unit loaded!");
        return;
      }
      const md = exportModalToMarkdown(currentModalDisplayItem);
      // Copy to clipboard:
      navigator.clipboard.writeText(md).then(() => {
        alert("Markdown copied to clipboard!");
      });
      // Optional: Uncomment the next line to also trigger download
      downloadMarkdown(md, currentModalDisplayItem.unit.titleCore || "export");
    };


    function downloadMarkdown(md, filename) {
      const blob = new Blob([md], {
        type: "text/markdown"
      });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename.replace(/\s+/g, '_') + ".md";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    document.getElementById('copy-plain-text-btn').onclick = function() {
      // Get the modal content as text (not HTML)
      var modalTextElem = document.getElementById('modal-text');
      if (!modalTextElem) {
        alert("No modal content found.");
        return;
      }
      // Get all text content (no formatting, no HTML tags)
      var plainText = modalTextElem.innerText || modalTextElem.textContent || "";
      if (!plainText) {
        alert("Nothing to copy!");
        return;
      }
      // Copy to clipboard
      navigator.clipboard.writeText(plainText).then(() => {
        alert("Plain text copied to clipboard!");
      });
    };



    function getTopSymbols(allUnits, topN = 20) {
      const symbolCounts = {};
      // List of symbols to omit
      const omit = new Set(["‚ü∂", "‚Üí", "‚åÅ", "‚ò≤", "‚ö†", "‚úñ", "‚äò", "‚ßó"]);

      function scanForSymbols(str) {
        if (typeof str !== "string") return;
        // Emoji & Symbols regex
        const regex = /[\p{Emoji}\p{So}\p{Sc}\p{Sk}\p{Sm}\p{S}]/gu;
        let matches = str.match(regex);
        if (matches) {
          matches.forEach(sym => {
            if (omit.has(sym)) return; // skip omitted symbols
            symbolCounts[sym] = (symbolCounts[sym] || 0) + 1;
          });
        }
      }

      function extractAllStrings(obj) {
        if (typeof obj === "string") scanForSymbols(obj);
        else if (Array.isArray(obj)) obj.forEach(extractAllStrings);
        else if (typeof obj === "object" && obj !== null)
          for (const k in obj) extractAllStrings(obj[k]);
      }

      allUnits.forEach(unit => extractAllStrings(unit));

      // Sort by count, descending
      const sorted = Object.entries(symbolCounts).sort((a, b) => b[1] - a[1]);
      return sorted.slice(0, topN);
    }


    function getTopWords(allUnits, topN = 20) {
      // Common English stop words to ignore (expand if you want!)
      const stopWords = new Set([
        "the", "and", "a", "of", "to", "in", "for", "on", "is", "with", "as", "by", "at", "an", "be", "are", "or", "that", "this", "it", "from", "was", "which", "but", "not", "have", "has", "had", "were", "will", "can", "if", "their", "so", "its", "may", "do", "does", "did", "our", "your", "my", "i", "me", "you", "we", "they", "them", "he", "she", "his", "her", "him", "us", "about", "into", "out", "up", "down", "over", "under", "then", "than", "would", "should", "could", "dreamstate", "echo", "s", "t", "am", "block", "triadic", "glyph", "breakdown", "what", "flow", "context", "just"
      ]);
      const counts = {};

      function extractAllStrings(obj) {
        if (typeof obj === "string") {
          // Split on non-letter (including numbers, punctuation, symbols)
          obj.toLowerCase().split(/[^a-zA-Z]+/).forEach(word => {
            if (!word || stopWords.has(word)) return;
            counts[word] = (counts[word] || 0) + 1;
          });
        } else if (Array.isArray(obj)) {
          obj.forEach(extractAllStrings);
        } else if (typeof obj === "object" && obj !== null) {
          for (const k in obj) extractAllStrings(obj[k]);
        }
      }

      allUnits.forEach(unit => extractAllStrings(unit));

      // Sort by count, descending
      const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
      return sorted.slice(0, topN);
    }


    function getTopAdjacentSymbolPairs(allUnits, topN = 20) {
      const omit = new Set(["‚ü∂", "‚åÅ", "‚ò≤", "‚ö†", "‚úñ", "‚äò", "‚ßó"]);
      const pairCounts = {};

      function scanForAdjacentPairs(str) {
        if (typeof str !== "string") return;
        const regex = /[\p{Emoji}\p{So}\p{Sc}\p{Sk}\p{Sm}\p{S}]/gu;
        const matches = (str.match(regex) || []).filter(sym => !omit.has(sym));
        for (let i = 0; i < matches.length - 1; ++i) {
          const a = matches[i],
            b = matches[i + 1];
          if (a === b) continue; // skip pairs of same symbol, optional
          const key = a + " " + b;
          pairCounts[key] = (pairCounts[key] || 0) + 1;
        }
      }

      function extractAllStrings(obj) {
        if (typeof obj === "string") scanForAdjacentPairs(obj);
        else if (Array.isArray(obj)) obj.forEach(extractAllStrings);
        else if (typeof obj === "object" && obj !== null)
          for (const k in obj) extractAllStrings(obj[k]);
      }

      allUnits.forEach(unit => extractAllStrings(unit));
      const sortedPairs = Object.entries(pairCounts).sort((a, b) => b[1] - a[1]);
      return sortedPairs.slice(0, topN);
    }


    // --- STAT CARD ---
    document.getElementById('show-stats-btn').onclick = function() {
      // 1. Gather all units (anywhere in rileyData)
      let allUnits = [];

      function collectUnits(obj) {
        if (!obj) return;
        if (Array.isArray(obj)) obj.forEach(collectUnits);
        else if (typeof obj === "object" && obj !== null) {
          // If this looks like a unit, add it
          if (obj.constructType && obj.titleCore) allUnits.push(obj);
          for (const k in obj) collectUnits(obj[k]);
        }
      }
      collectUnits(rileyData);

      // 2. Count interesting things
      let stats = {
        total: allUnits.length,
        lattices: allUnits.filter(u => u.constructType === "NARRATIVE LATTICE").length,
        echoes: allUnits.filter(u => u.constructType === "DREAMSTATE ECHO").length,
        coreUnits: allUnits.filter(u => u.constructType === "CORE UNIT INTEGRATION").length,
        // Add more as you wish!
      };

      // 3. Top 20 Symbols
      const topSymbols = getTopSymbols(allUnits, 20);
      let symbolHtml = '<h3>Top 20 Symbols</h3><ul>';
      topSymbols.forEach(([sym, count]) => {
        symbolHtml += `<li style="font-size:1.5em;display:inline-block;width:2em;text-align:center">${sym}</li>: ${count}<br>`;
      });
      symbolHtml += '</ul>';


      // 4. Top 20 Words
      const topWords = getTopWords(allUnits, 20);
      let wordsHtml = '<h3>Top 20 Words</h3><ul>';
      topWords.forEach(([word, count]) => {
        wordsHtml += `<li><strong>${word}</strong>: ${count}</li>`;
      });
      wordsHtml += '</ul>';

      // 5. Top 20 Symbol Pairs
      const topAdjacentSymbolPairs = getTopAdjacentSymbolPairs(allUnits, 20);
      let pairsHtml = '<h3>Top 20 Adjacent Symbol Pairs</h3><ul>';
      topAdjacentSymbolPairs.forEach(([pair, count]) => {
        pairsHtml += `<li style="font-size:1.4em">${pair.replace(' ', ' &nbsp;')} : <span style="font-size:0.8em">${count}</span></li>`;
      });
      pairsHtml += '</ul>';


      // 6. Format nice HTML for the modal
      let html = `<h2>Stats</h2><ul>`;
      for (const [label, value] of Object.entries(stats)) {
        html += `<li><strong>${label}:</strong> ${value}</li>`;
      }
      html += `</ul>`;
      html += symbolHtml;
      html += pairsHtml;
      html += wordsHtml;
      html += `<button onclick="document.getElementById('stats-modal').style.display='none'">Close</button>`;

      // 7. Show modal
      const modal = document.getElementById('stats-modal');
      modal.innerHTML = html;
      modal.style.display = 'block';
    };



    // --- CURSOR SHIMMER ---

    document.addEventListener('mousemove', function(e) {
      const shimmer = document.createElement('div');
      shimmer.classList.add('cursor-shimmer');
      document.body.appendChild(shimmer);
      shimmer.style.left = `${e.clientX - shimmer.offsetWidth / 2}px`;
      shimmer.style.top = `${e.clientY - shimmer.offsetHeight / 2}px`;
      shimmer.addEventListener('animationend', () => {
        shimmer.remove();
      });
    });

    // --- CLOSE MODAL BINDING ---

    // --- Stats Modal: Click-outside-to-close and ESC-to-close ---
    document.addEventListener('mousedown', function(e) {
      const modal = document.getElementById('stats-modal');
      // Only act if the modal is open
      if (modal.style.display === 'block') {
        // If the click is outside the modal (not inside its children or the button)
        if (!modal.contains(e.target) && e.target.id !== 'show-stats-btn') {
          modal.style.display = 'none';
        }
      }
    });
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        document.getElementById('stats-modal').style.display = 'none';
      }
    });

document.addEventListener('DOMContentLoaded', function() {
  loadProfile(currentProfileIndex); // This loads the initial profile and background!
  document.querySelector('.modal-close').onclick = closeModal;
});


  </script>
</body>

</html>